#!/usr/bin/env python3
"""
Bot de Trading ADA/USDT - Vers√£o Completa
Compra em quedas (degraus) e vende em altas (metas)
"""

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent))

import time
from decimal import Decimal
from datetime import datetime, timedelta
from typing import Optional, Dict, List

from config.settings import settings
from src.comunicacao.api_manager import APIManager
from src.core.gerenciador_aportes import GerenciadorAportes
from src.core.gerenciador_bnb import GerenciadorBNB
from src.core.analise_tecnica import AnaliseTecnica
from src.core.gestao_capital import GestaoCapital
from src.persistencia.database import DatabaseManager
from src.persistencia.state_manager import StateManager
from src.utils.logger import get_logger
from src.utils.constants import Icones, LogConfig

# Configurar logger com formato configur√°vel
logger = get_logger(
    log_dir=Path('logs'),
    config=LogConfig.DEFAULT,  # Usa configura√ß√£o padr√£o (produ√ß√£o)
    console=True
)


class TradingBot:
    """Bot de Trading ADA/USDT"""

    def __init__(self):
        """Inicializar bot"""
        self.api = APIManager(
            api_key=settings.BINANCE_API_KEY,
            api_secret=settings.BINANCE_API_SECRET,
            base_url=settings.BINANCE_API_URL
        )

        self.gerenciador_aportes = GerenciadorAportes(self.api, settings)
        self.gerenciador_bnb = GerenciadorBNB(self.api, settings)
        self.analise_tecnica = AnaliseTecnica(self.api)
        self.gestao_capital = GestaoCapital()  # Gestor de capital com valida√ß√£o de reserva

        # Banco de dados (somente para ordens e hist√≥rico)
        self.db = DatabaseManager(
            db_path=settings.DATABASE_PATH,
            backup_dir=settings.BACKUP_DIR
        )

        # Gerenciador de estado operacional (cooldowns, timestamps)
        self.state = StateManager(state_file_path='dados/bot_state.json')

        # Estado do bot
        self.sma_referencia: Optional[Decimal] = None  # SMA de 4 semanas como refer√™ncia
        self.sma_1h: Optional[Decimal] = None
        self.sma_4h: Optional[Decimal] = None
        self.ultima_atualizacao_sma = None
        self.ultimo_backup = datetime.now()
        self.rodando = False
        self.inicio_bot = datetime.now()  # Timestamp de in√≠cio para calcular uptime

        # Controle de verifica√ß√£o de aportes BRL
        self.aportes_config = settings.APORTES
        self.intervalo_verificacao_aportes = timedelta(minutes=self.aportes_config['intervalo_verificacao_minutos'])
        self.ultima_verificacao_aportes = datetime.now() - self.intervalo_verificacao_aportes

        # Hist√≥rico de pre√ßos (√∫ltimos 100)
        self.historico_precos: List[Decimal] = []

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # NOVA ESTRAT√âGIA: Largada a Frio + Cooldown Duplo
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        self.primeira_execucao: bool = True  # Detecta se √© a primeira execu√ß√£o
        # NOTA: timestamp_ultima_compra_global agora √© gerenciado via StateManager

        # Controle de spam de logs (evita logar "Degrau X ativado" repetidamente)
        self.ultima_tentativa_log_degrau: Dict[int, datetime] = {}  # {nivel_degrau: timestamp_ultimo_log}

        # Rastreamento de degraus bloqueados (para notifica√ß√µes inteligentes)
        self.degraus_notificados_bloqueados: set = set()  # Degraus que j√° foram notificados como bloqueados

        # Controle de notifica√ß√£o de exposi√ß√£o m√°xima
        self.notificou_exposicao_maxima: bool = False

        # Estado operacional do bot
        self.estado_bot: str = "OPERANDO"  # "OPERANDO" ou "AGUARDANDO_SALDO"
        self.ja_avisou_sem_saldo: bool = False  # Evita avisar repetidamente

        # Rastreamento de pre√ßo m√©dio de compra (para calcular lucro)
        self.preco_medio_compra: Optional[Decimal] = None
        self.quantidade_total_comprada: Decimal = Decimal('0')
        self.valor_total_investido: Decimal = Decimal('0')

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ESTRAT√âGIA AVAN√áADA: High-Water Mark e Zonas de Seguran√ßa
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        self.high_water_mark_profit: Decimal = Decimal('0')  # Maior lucro % atingido na escalada atual
        self.zonas_de_seguranca_acionadas: set = set()  # Nomes das zonas j√° acionadas
        self.capital_para_recompra: Dict[str, Dict] = {}  # {nome_zona: {'capital_usdt': X, 'high_mark': Y}}

        # Recuperar estado do banco de dados (se existir)
        self._recuperar_estado_do_banco()

    def _recuperar_estado_do_banco(self):
        """
        Recupera estado anterior do bot a partir do banco de dados.
        Isso permite que o bot continue de onde parou ap√≥s rein√≠cio.
        """
        try:
            estado = self.db.recuperar_estado_bot()

            if estado:
                self.preco_medio_compra = estado.get('preco_medio_compra')
                self.quantidade_total_comprada = estado.get('quantidade_total_ada', Decimal('0'))

                # Recalcular valor total investido
                if self.preco_medio_compra and self.quantidade_total_comprada > 0:
                    self.valor_total_investido = self.preco_medio_compra * self.quantidade_total_comprada

                    logger.info("üîÑ Estado recuperado do banco de dados:")
                    logger.info(f"   Pre√ßo m√©dio: ${self.preco_medio_compra:.6f}")
                    logger.info(f"   Quantidade (local): {self.quantidade_total_comprada:.1f} ADA")
                    logger.info(f"   Valor investido: ${self.valor_total_investido:.2f} USDT")
                else:
                    logger.info("üìä Iniciando com estado limpo (sem posi√ß√µes anteriores)")
            else:
                logger.info("üìä Nenhum estado anterior encontrado - iniciando do zero")

            # Recuperar timestamp da √∫ltima compra global (para cooldown global)
            self._recuperar_timestamp_ultima_compra_global()

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Erro ao recuperar estado do banco: {e}")
            logger.info("üìä Continuando com estado limpo")

    def _sincronizar_saldos_binance(self):
        """
        CR√çTICO: Sincroniza saldos (ADA e USDT) reais da Binance com estado local.

        Isso garante que:
        1. O bot sempre inicia com o saldo REAL da Binance
        2. Diverg√™ncias entre backup local e Binance s√£o corrigidas
        3. Compras/vendas feitas manualmente s√£o detectadas

        Executado no in√≠cio do bot e ap√≥s convers√µes de BRL.
        """
        try:
            logger.info("üîÑ Sincronizando saldos com a Binance...")

            # Buscar saldo real da API Binance
            saldos_binance = self.obter_saldos()
            saldo_ada_real = saldos_binance['ada']
            saldo_usdt_real = saldos_binance['usdt']

            # Comparar com estado local
            saldo_ada_local = self.quantidade_total_comprada

            logger.info(f"üìä Saldo local (backup): {saldo_ada_local:.1f} ADA")
            logger.info(f"üìä Saldo Binance (real): {saldo_ada_real:.1f} ADA | ${saldo_usdt_real:.2f} USDT")

            # Verificar diverg√™ncia
            diferenca = abs(saldo_ada_real - saldo_ada_local)

            if diferenca >= Decimal('0.1'):  # Diferen√ßa significativa (>= 0.1 ADA)
                logger.warning("‚ö†Ô∏è DIVERG√äNCIA DETECTADA entre backup local e Binance!")
                logger.warning(f"   Diferen√ßa: {diferenca:.1f} ADA")
                logger.warning("")
                logger.warning("üîÑ Sincronizando com saldo REAL da Binance...")

                # Atualizar quantidade com saldo real da Binance
                self.quantidade_total_comprada = saldo_ada_real

                # Recalcular valor investido (mantendo pre√ßo m√©dio se existir)
                if self.preco_medio_compra and self.quantidade_total_comprada > 0:
                    self.valor_total_investido = self.preco_medio_compra * self.quantidade_total_comprada
                    logger.info(f"‚úÖ Posi√ß√£o sincronizada: {self.quantidade_total_comprada:.1f} ADA")
                    logger.info(f"   Pre√ßo m√©dio mantido: ${self.preco_medio_compra:.6f}")
                    logger.info(f"   Valor investido recalculado: ${self.valor_total_investido:.2f} USDT")
                elif self.quantidade_total_comprada > 0:
                    # Tem ADA mas n√£o tem pre√ßo m√©dio - calcular baseado em pre√ßo atual
                    preco_atual = self.obter_preco_atual()
                    if preco_atual:
                        self.preco_medio_compra = preco_atual
                        self.valor_total_investido = self.quantidade_total_comprada * preco_atual
                        logger.warning("‚ö†Ô∏è Pre√ßo m√©dio n√£o encontrado - usando pre√ßo atual como refer√™ncia")
                        logger.info(f"   Pre√ßo atual: ${preco_atual:.6f}")
                        logger.info(f"   Valor investido estimado: ${self.valor_total_investido:.2f} USDT")
                else:
                    # N√£o tem ADA - zerar estado
                    self.preco_medio_compra = None
                    self.valor_total_investido = Decimal('0')
                    logger.info("‚úÖ Posi√ß√£o zerada (sem ADA na Binance)")

                # Atualizar estado no banco com valores sincronizados
                self.db.atualizar_estado_bot(
                    preco_medio=self.preco_medio_compra,
                    quantidade=self.quantidade_total_comprada
                )
                logger.info("üíæ Backup local atualizado com saldo da Binance")
            else:
                logger.info("‚úÖ Saldo local sincronizado com Binance")

            logger.info(f"üíº Saldo final confirmado: {self.quantidade_total_comprada:.1f} ADA | ${saldo_usdt_real:.2f} USDT")
            logger.info("")

        except Exception as e:
            logger.error(f"‚ùå Erro ao sincronizar saldo com Binance: {e}")
            logger.warning("‚ö†Ô∏è Continuando com saldo local (pode estar desatualizado)")

    def _recuperar_timestamp_ultima_compra_global(self):
        """
        Recupera o timestamp da √∫ltima compra global do StateManager.
        Isso garante que o cooldown global seja respeitado ap√≥s rein√≠cio do bot.
        """
        try:
            timestamp_str = self.state.get_state('ultima_compra_global_ts')

            if timestamp_str:
                timestamp_compra = datetime.fromisoformat(timestamp_str)
                tempo_decorrido = datetime.now() - timestamp_compra
                minutos = int(tempo_decorrido.total_seconds() / 60)
                logger.info(f"üïí √öltima compra global: h√° {minutos} minutos")
            # NOTA: N√£o loga nada se n√£o encontrar timestamp, pois isso √© esperado
            # quando o banco est√° vazio ou quando √© realmente a primeira execu√ß√£o

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Erro ao recuperar timestamp da √∫ltima compra: {e}")
            logger.info("üìã Continuando sem hist√≥rico")

    def importar_historico_binance(self, simbolo: str = 'ADAUSDT', limite: int = 500):
        """
        Importa hist√≥rico de ordens da Binance para o banco de dados.

        Args:
            simbolo: Par de moedas (padr√£o: ADAUSDT)
            limite: N√∫mero m√°ximo de ordens a importar (padr√£o: 500)

        Returns:
            Dicion√°rio com estat√≠sticas da importa√ß√£o
        """
        try:
            logger.info(f"üì• Importando hist√≥rico de ordens da Binance ({simbolo})...")

            # Buscar ordens da Binance
            ordens = self.api.obter_historico_ordens(simbolo=simbolo, limite=limite)

            if not ordens:
                logger.info("üì≠ Nenhuma ordem encontrada no hist√≥rico da Binance")
                return {'importadas': 0, 'duplicadas': 0, 'erros': 0}

            logger.info(f"üìã Encontradas {len(ordens)} ordens no hist√≥rico da Binance")

            # Importar para o banco de dados
            resultado = self.db.importar_ordens_binance(ordens, recalcular_preco_medio=True)

            logger.info(f"‚úÖ Importa√ß√£o conclu√≠da:")
            logger.info(f"   Importadas: {resultado['importadas']}")
            logger.info(f"   Duplicadas: {resultado['duplicadas']}")
            logger.info(f"   Erros: {resultado['erros']}")

            # Atualizar estado do bot com valores recalculados
            if resultado['importadas'] > 0:
                self._recuperar_estado_do_banco()

            return resultado

        except Exception as e:
            logger.error(f"‚ùå Erro ao importar hist√≥rico: {e}")
            return {'importadas': 0, 'duplicadas': 0, 'erros': 1}

    def obter_preco_atual(self) -> Optional[Decimal]:
        """Obt√©m pre√ßo atual de ADA/USDT"""
        try:
            ticker = self.api.obter_ticker('ADAUSDT')
            preco = Decimal(str(ticker['price']))

            # Adicionar ao hist√≥rico
            self.historico_precos.append(preco)
            if len(self.historico_precos) > settings.TAMANHO_BUFFER_PRECOS:
                self.historico_precos.pop(0)

            return preco
        except Exception as e:
            logger.erro_api('obter_preco_atual', str(e))
            return None

    def obter_saldos(self) -> Dict:
        """Obt√©m saldos de USDT e ADA"""
        try:
            saldos_raw = self.api.obter_saldos()

            saldo_usdt = Decimal('0')
            saldo_ada = Decimal('0')

            for saldo in saldos_raw:
                if saldo['asset'] == 'USDT':
                    saldo_usdt = Decimal(str(saldo['free']))
                elif saldo['asset'] == 'ADA':
                    saldo_ada = Decimal(str(saldo['free']))

            return {
                'usdt': saldo_usdt,
                'ada': saldo_ada
            }
        except Exception as e:
            logger.erro_api('obter_saldos', str(e))
            return {'usdt': Decimal('0'), 'ada': Decimal('0')}

    def atualizar_sma(self):
        """
        Atualiza SMA de 4 semanas (refer√™ncia de "pico")
        Atualiza a cada 1 hora para economizar API calls
        """
        agora = datetime.now()

        # Atualizar apenas se passou 1 hora ou se nunca foi calculada
        if (self.ultima_atualizacao_sma is None or
            (agora - self.ultima_atualizacao_sma) >= timedelta(hours=1)):

            logger.info("üîÑ Atualizando SMA de refer√™ncia (4 semanas)...")

            smas = self.analise_tecnica.calcular_sma_multiplos_timeframes(
                simbolo='ADAUSDT',
                periodo_dias=28  # 4 semanas
            )

            if smas:
                self.sma_1h = smas.get('1h')
                self.sma_4h = smas.get('4h')
                self.sma_referencia = smas.get('media')  # M√©dia ponderada
                self.ultima_atualizacao_sma = agora

                logger.info(f"‚úÖ SMA de refer√™ncia atualizada: ${self.sma_referencia:.6f}")
            else:
                logger.error("‚ùå N√£o foi poss√≠vel atualizar SMA")

    def calcular_queda_percentual(self, preco_atual: Decimal) -> Optional[Decimal]:
        """Calcula queda % desde a SMA de refer√™ncia"""
        if self.sma_referencia is None:
            return None

        queda = ((self.sma_referencia - preco_atual) / self.sma_referencia) * Decimal('100')
        return queda

    def encontrar_degrau_ativo(self, queda_pct: Decimal) -> Optional[Dict]:
        """Encontra degrau de compra correspondente"""
        for degrau in settings.DEGRAUS_COMPRA:
            if queda_pct >= Decimal(str(degrau['queda_percentual'])):
                return degrau
        return None

    def encontrar_degrau_mais_profundo(self, queda_pct: Decimal) -> Optional[Dict]:
        """
        Encontra o degrau MAIS PROFUNDO que foi ativado pela queda atual.

        Usado na l√≥gica de "Largada a Frio" para comprar no degrau mais agressivo
        dispon√≠vel na primeira execu√ß√£o.

        Args:
            queda_pct: Percentual de queda desde a SMA de refer√™ncia

        Returns:
            Degrau mais profundo ativado ou None se nenhum foi ativado
        """
        degrau_mais_profundo = None

        for degrau in settings.DEGRAUS_COMPRA:
            if queda_pct >= Decimal(str(degrau['queda_percentual'])):
                # Como os degraus est√£o ordenados por queda crescente,
                # o √∫ltimo que passar na verifica√ß√£o √© o mais profundo
                degrau_mais_profundo = degrau

        return degrau_mais_profundo

    def pode_comprar_degrau(self, nivel_degrau: int, degrau_config: Dict) -> tuple[bool, Optional[str]]:
        """
        Verifica se pode comprar no degrau usando COOLDOWN DUPLO:
        1. Cooldown GLOBAL: Tempo m√≠nimo desde QUALQUER compra
        2. Cooldown POR DEGRAU: Tempo m√≠nimo desde √∫ltima compra NO MESMO DEGRAU

        Args:
            nivel_degrau: N√≠vel do degrau (1, 2, 3, etc)
            degrau_config: Configura√ß√£o do degrau (incluindo intervalo_horas)

        Returns:
            Tuple (pode_comprar, motivo_bloqueio):
                - pode_comprar: True se pode comprar, False caso contr√°rio
                - motivo_bloqueio: String com motivo do bloqueio ou None se pode comprar
        """
        agora = datetime.now()

        # VERIFICA√á√ÉO 1: COOLDOWN GLOBAL (ap√≥s qualquer compra)
        cooldown_global_minutos = settings.COOLDOWN_GLOBAL_APOS_COMPRA_MINUTOS

        timestamp_global_str = self.state.get_state('ultima_compra_global_ts')
        if timestamp_global_str:
            timestamp_ultima_compra_global = datetime.fromisoformat(timestamp_global_str)
            tempo_desde_ultima_compra = agora - timestamp_ultima_compra_global
            minutos_decorridos = tempo_desde_ultima_compra.total_seconds() / 60

            if minutos_decorridos < cooldown_global_minutos:
                minutos_restantes = int(cooldown_global_minutos - minutos_decorridos)
                motivo = f"cooldown_global:{minutos_restantes}min"
                logger.debug(f"üïí Cooldown global ativo (faltam {minutos_restantes} min)")
                return (False, motivo)

        # VERIFICA√á√ÉO 2: COOLDOWN POR DEGRAU (intervalo espec√≠fico do degrau)
        chave_degrau = f'ultima_compra_degrau_{nivel_degrau}_ts'
        timestamp_degrau_str = self.state.get_state(chave_degrau)

        if timestamp_degrau_str:
            ultima_compra_degrau = datetime.fromisoformat(timestamp_degrau_str)
            tempo_desde_compra_degrau = agora - ultima_compra_degrau
            intervalo_horas = Decimal(str(degrau_config['intervalo_horas']))
            horas_decorridas = Decimal(str(tempo_desde_compra_degrau.total_seconds() / 3600))

            if horas_decorridas < intervalo_horas:
                horas_restantes = float(intervalo_horas - horas_decorridas)
                motivo = f"cooldown_degrau:{horas_restantes:.1f}h"
                logger.debug(f"üïí Degrau {nivel_degrau} em cooldown (faltam {horas_restantes:.1f}h)")
                return (False, motivo)

        # Passou em todas as verifica√ß√µes
        return (True, None)

    def registrar_compra_global(self, nivel_degrau: Optional[int] = None):
        """
        Registra timestamp da √∫ltima compra (COOLDOWN GLOBAL)

        Atualiza o timestamp global que bloqueia TODAS as compras
        por um per√≠odo configur√°vel ap√≥s cada opera√ß√£o de compra.

        Args:
            nivel_degrau: N√≠vel do degrau (para registrar cooldown por degrau)
        """
        agora = datetime.now()
        timestamp_iso = agora.isoformat()

        # Registrar cooldown global
        self.state.set_state('ultima_compra_global_ts', timestamp_iso)
        logger.debug(f"üïí Cooldown global ativado: {settings.COOLDOWN_GLOBAL_APOS_COMPRA_MINUTOS} minutos")

        # Registrar cooldown por degrau (se especificado)
        if nivel_degrau is not None:
            chave_degrau = f'ultima_compra_degrau_{nivel_degrau}_ts'
            self.state.set_state(chave_degrau, timestamp_iso)
            logger.debug(f"üïí Cooldown degrau {nivel_degrau} ativado")

    def atualizar_preco_medio_compra(self, quantidade: Decimal, preco: Decimal):
        """
        Atualiza o pre√ßo m√©dio de compra ap√≥s nova compra

        F√≥rmula: novo_pre√ßo_m√©dio = (valor_anterior + valor_nova_compra) / (qtd_anterior + qtd_nova)
        """
        valor_compra = quantidade * preco

        self.valor_total_investido += valor_compra
        self.quantidade_total_comprada += quantidade

        if self.quantidade_total_comprada > 0:
            self.preco_medio_compra = self.valor_total_investido / self.quantidade_total_comprada
            logger.info(f"üìä Pre√ßo m√©dio atualizado: ${self.preco_medio_compra:.6f} ({self.quantidade_total_comprada:.1f} ADA)")
        else:
            self.preco_medio_compra = None

    def calcular_lucro_atual(self, preco_atual: Decimal) -> Optional[Decimal]:
        """
        Calcula lucro % baseado no pre√ßo m√©dio de compra

        Returns:
            Lucro em % (positivo = lucro, negativo = preju√≠zo)
            None se n√£o houver pre√ßo m√©dio calculado
        """
        if self.preco_medio_compra is None or self.preco_medio_compra == 0:
            return None

        lucro_pct = ((preco_atual - self.preco_medio_compra) / self.preco_medio_compra) * Decimal('100')
        return lucro_pct

    def executar_compra(self, degrau: Dict, preco_atual: Decimal, saldo_usdt: Decimal):
        """Executa compra no degrau com valida√ß√£o rigorosa de reserva"""
        quantidade_ada = Decimal(str(degrau['quantidade_ada']))
        valor_ordem = quantidade_ada * preco_atual

        # VALIDA√á√ÉO RIGOROSA DE SALDO E RESERVA
        # Atualizar saldos no gestor de capital
        valor_posicao_ada = self.quantidade_total_comprada * preco_atual if self.quantidade_total_comprada > 0 else Decimal('0')
        self.gestao_capital.atualizar_saldos(saldo_usdt, valor_posicao_ada)

        # Verificar se pode comprar (valida reserva + saldo m√≠nimo)
        pode, motivo = self.gestao_capital.pode_comprar(valor_ordem)

        if not pode:
            # NOTA: o log j√° foi feito dentro de gestao_capital.pode_comprar()
            # N√£o relogar para evitar duplica√ß√£o
            return False

        # Verificar valor m√≠nimo de ordem
        if valor_ordem < settings.VALOR_MINIMO_ORDEM:
            logger.warning(f"‚ö†Ô∏è Valor de ordem abaixo do m√≠nimo: ${valor_ordem:.2f}")
            return False

        try:
            # Capturar saldos antes da compra
            saldos_antes = self.obter_saldos()
            preco_medio_antes = self.preco_medio_compra

            # Criar ordem de compra
            ordem = self.api.criar_ordem_mercado(
                simbolo='ADAUSDT',
                lado='BUY',
                quantidade=float(quantidade_ada)
            )

            if ordem and ordem.get('status') == 'FILLED':
                logger.operacao_compra(
                    par='ADA/USDT',
                    quantidade=float(quantidade_ada),
                    preco=float(preco_atual),
                    degrau=degrau['nivel'],
                    queda_pct=float(degrau['queda_percentual'])
                )

                # Registrar compra e ativar cooldown global + cooldown por degrau
                self.registrar_compra_global(nivel_degrau=degrau['nivel'])

                # Atualizar pre√ßo m√©dio de compra
                self.atualizar_preco_medio_compra(quantidade_ada, preco_atual)

                # Capturar saldos depois da compra
                saldos_depois = self.obter_saldos()

                # SALVAR NO BANCO DE DADOS
                self.db.registrar_ordem({
                    'tipo': 'COMPRA',
                    'par': 'ADA/USDT',
                    'quantidade': quantidade_ada,
                    'preco': preco_atual,
                    'valor_total': valor_ordem,
                    'taxa': ordem.get('fills', [{}])[0].get('commission', 0) if ordem.get('fills') else 0,
                    'meta': f"degrau{degrau['nivel']}",
                    'preco_medio_antes': preco_medio_antes,
                    'preco_medio_depois': self.preco_medio_compra,
                    'saldo_ada_antes': saldos_antes['ada'],
                    'saldo_ada_depois': saldos_depois['ada'],
                    'saldo_usdt_antes': saldos_antes['usdt'],
                    'saldo_usdt_depois': saldos_depois['usdt'],
                    'order_id': ordem.get('orderId'),
                    'observacao': f"Compra degrau {degrau['nivel']} - Queda {degrau['queda_percentual']}%"
                })

                # Atualizar estado do bot no banco
                self.db.atualizar_estado_bot(
                    preco_medio=self.preco_medio_compra,
                    quantidade=self.quantidade_total_comprada
                )

                return True
            else:
                logger.error(f"‚ùå Erro ao executar compra: {ordem}")
                return False

        except Exception as e:
            logger.erro_api('executar_compra', str(e))
            return False

    def executar_compra_por_valor(self, valor_usdt: Decimal, motivo: str) -> bool:
        """Executa uma compra baseada em um valor em USDT."""
        preco_atual = self.obter_preco_atual()
        if not preco_atual:
            logger.error("‚ùå N√£o foi poss√≠vel obter o pre√ßo atual para a compra por valor.")
            return False

        # Calcula a quantidade de ADA a comprar
        quantidade_ada = valor_usdt / preco_atual

        # Valida√ß√£o de valor m√≠nimo da ordem
        if valor_usdt < settings.VALOR_MINIMO_ORDEM:
            logger.warning(f"‚ö†Ô∏è Valor de ordem abaixo do m√≠nimo: ${valor_usdt:.2f}")
            return False

        try:
            saldos_antes = self.obter_saldos()
            preco_medio_antes = self.preco_medio_compra

            ordem = self.api.criar_ordem_mercado(
                simbolo='ADAUSDT',
                lado='BUY',
                quantidade=float(quantidade_ada)
            )

            if ordem and ordem.get('status') == 'FILLED':
                quantidade_real = Decimal(str(ordem.get('executedQty', '0')))
                valor_real = Decimal(str(ordem.get('cummulativeQuoteQty', '0')))

                logger.operacao_compra(
                    par='ADA/USDT',
                    quantidade=float(quantidade_real),
                    preco=float(preco_atual),
                    degrau=motivo.replace(" ", "_"),
                    queda_pct=0  # N√£o aplic√°vel para este tipo de compra
                )

                self.registrar_compra_global()
                self.atualizar_preco_medio_compra(quantidade_real, preco_atual)

                saldos_depois = self.obter_saldos()

                self.db.registrar_ordem({
                    'tipo': 'COMPRA',
                    'par': 'ADA/USDT',
                    'quantidade': quantidade_real,
                    'preco': preco_atual,
                    'valor_total': valor_real,
                    'taxa': ordem.get('fills', [{}])[0].get('commission', 0) if ordem.get('fills') else 0,
                    'meta': motivo.replace(" ", "_"),
                    'preco_medio_antes': preco_medio_antes,
                    'preco_medio_depois': self.preco_medio_compra,
                    'saldo_ada_antes': saldos_antes['ada'],
                    'saldo_ada_depois': saldos_depois['ada'],
                    'saldo_usdt_antes': saldos_antes['usdt'],
                    'saldo_usdt_depois': saldos_depois['usdt'],
                    'order_id': ordem.get('orderId'),
                    'observacao': f"Compra de Oportunidade: {motivo}"
                })

                self.db.atualizar_estado_bot(
                    preco_medio=self.preco_medio_compra,
                    quantidade=self.quantidade_total_comprada
                )

                return True
            else:
                logger.error(f"‚ùå Erro ao executar compra por valor: {ordem}")
                return False
        except Exception as e:
            logger.erro_api('executar_compra_por_valor', str(e))
            return False

    def encontrar_meta_ativa(self, lucro_pct: Decimal, saldo_ada: Decimal, preco_atual: Decimal) -> Optional[Dict]:
        """
        Encontra meta de venda correspondente ao lucro atual

        ESTRAT√âGIA AVAN√áADA COM ZONAS DE SEGURAN√áA:

        1. Atualizar High-Water Mark se lucro atual √© maior
        2. PRIORIDADE 1: Verificar METAS FIXAS (18%, 11%, 6%)
           - Se atingida: executar venda principal e RESETAR estado
        3. PRIORIDADE 2: Verificar ZONAS DE SEGURAN√áA (vendas de prote√ß√£o)
           - Verificar se high_water_mark ultrapassou gatilho
           - Verificar se lucro atual caiu (revers√£o detectada)
           - Executar venda de seguran√ßa parcial
        4. PRIORIDADE 3: Sistema ADAPTATIVO (3-6%)

        REGRA CR√çTICA: S√≥ vende se houver LUCRO (nunca vende com preju√≠zo)
        """
        if lucro_pct <= 0:
            return None  # Sem lucro, n√£o vende

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ATUALIZAR HIGH-WATER MARK
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if lucro_pct > self.high_water_mark_profit:
            self.high_water_mark_profit = lucro_pct
            logger.debug(f"üìä High-Water Mark atualizado: {self.high_water_mark_profit:.2f}%")

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # PRIORIDADE 1: Verificar METAS FIXAS em ordem DECRESCENTE
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # Ordenar metas por lucro percentual (maior para menor)
        metas_ordenadas = sorted(
            settings.METAS_VENDA,
            key=lambda x: x['lucro_percentual'],
            reverse=True
        )

        # Verificar se alguma meta fixa foi atingida
        for meta in metas_ordenadas:
            if lucro_pct >= Decimal(str(meta['lucro_percentual'])):
                logger.debug(f"‚úÖ Meta fixa {meta['meta']} atingida ({meta['lucro_percentual']}%)")

                # IMPORTANTE: Resetar estado para pr√≥xima escalada
                self.high_water_mark_profit = Decimal('0')
                self.zonas_de_seguranca_acionadas.clear()
                self.capital_para_recompra.clear()

                return meta

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # PRIORIDADE 2: Verificar ZONAS DE SEGURAN√áA (vendas progressivas)
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # SISTEMA DE DOIS GATILHOS:
        # 1. gatilho_ativacao_lucro_pct: "arma" a zona quando high-water mark ultrapassa
        # 2. gatilho_venda_reversao_pct: dispara a venda quando lucro cai este valor desde o pico
        if hasattr(settings, 'VENDAS_DE_SEGURANCA') and settings.VENDAS_DE_SEGURANCA:
            for zona in settings.VENDAS_DE_SEGURANCA:
                nome_zona = zona['nome']

                # GATILHO 1: Ativa√ß√£o - High-water mark deve ultrapassar este valor
                gatilho_ativacao_pct = Decimal(str(zona['gatilho_ativacao_lucro_pct']))

                # GATILHO 2: Revers√£o - Quanto deve cair desde o pico para vender
                gatilho_reversao_pct = Decimal(str(zona['gatilho_venda_reversao_pct']))

                # Verificar se zona j√° foi acionada
                if nome_zona in self.zonas_de_seguranca_acionadas:
                    continue

                # PASSO 1: Verificar se high-water mark "armou" o gatilho da zona
                if self.high_water_mark_profit < gatilho_ativacao_pct:
                    continue

                # PASSO 2: Calcular revers√£o desde high-water mark
                queda_desde_pico = self.high_water_mark_profit - lucro_pct

                # PASSO 3: Calcular gatilho de venda baseado na revers√£o configurada
                gatilho_venda = self.high_water_mark_profit - gatilho_reversao_pct

                # PASSO 4: Verificar se lucro atual caiu abaixo do gatilho de venda
                if lucro_pct <= gatilho_venda:
                    # Calcular valor da ordem
                    percentual_venda = Decimal(str(zona['percentual_venda_posicao'])) / Decimal('100')
                    quantidade_venda = saldo_ada * percentual_venda

                    # Arredondar para 0.1 (step size ADA)
                    quantidade_venda = (quantidade_venda * Decimal('10')).quantize(
                        Decimal('1'), rounding='ROUND_DOWN'
                    ) / Decimal('10')

                    valor_ordem = quantidade_venda * preco_atual

                    # Validar valor m√≠nimo
                    if valor_ordem >= settings.VALOR_MINIMO_ORDEM and quantidade_venda >= Decimal('1'):
                        logger.info(f"üõ°Ô∏è ZONA DE SEGURAN√áA '{nome_zona}' ATIVADA!")
                        logger.info(f"   üìä High-Water Mark: {self.high_water_mark_profit:.2f}%")
                        logger.info(f"   üéØ Gatilho ativa√ß√£o: {gatilho_ativacao_pct:.2f}% (armada ‚úì)")
                        logger.info(f"   üìâ Lucro atual: {lucro_pct:.2f}%")
                        logger.info(f"   üéØ Gatilho venda: {gatilho_venda:.2f}% (atingido ‚úì)")
                        logger.info(f"   üìä Queda desde pico: {queda_desde_pico:.2f}%")
                        logger.info(f"   üí∞ Venda de seguran√ßa: {float(quantidade_venda):.1f} ADA (${valor_ordem:.2f})")

                        return {
                            'meta': f'seguranca_{nome_zona}',
                            'lucro_percentual': float(lucro_pct),
                            'percentual_venda': zona['percentual_venda_posicao'],
                            'zona_seguranca': zona,  # Incluir dados completos da zona
                            'tipo_venda': 'seguranca'
                        }

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # NOTA: Sistema adaptativo REMOVIDO
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # A l√≥gica de "meta adaptativa" foi completamente removida para evitar
        # over-trading. Agora o bot opera APENAS com:
        # 1. Metas fixas (prioridade m√°xima)
        # 2. Zonas de seguran√ßa baseadas em revers√£o (prote√ß√£o inteligente)
        #
        # Esta mudan√ßa garante que pequenas flutua√ß√µes de mercado n√£o causem
        # vendas repetitivas que impedem o lucro de atingir as metas principais.

        return None  # Nenhuma meta atingida

    def executar_venda(self, meta: Dict, preco_atual: Decimal, saldo_ada: Decimal):
        """
        Executa venda na meta

        PROTE√á√ÉO: S√≥ executa se houver lucro confirmado

        VENDAS DE SEGURAN√áA:
        - Se for venda de seguran√ßa, guarda capital para recompra futura
        - Marca zona como acionada para n√£o repetir venda
        """
        # Verificar lucro novamente antes de vender
        lucro_pct = self.calcular_lucro_atual(preco_atual)

        if lucro_pct is None or lucro_pct <= 0:
            logger.warning(f"üõ°Ô∏è VENDA BLOQUEADA: Sem lucro ({lucro_pct:.2f}% - aguardando lucro)")
            return False

        percentual_venda = Decimal(str(meta['percentual_venda'])) / Decimal('100')
        quantidade_venda = saldo_ada * percentual_venda

        # Arredondar para 0.1 (step size ADA na Binance)
        quantidade_venda = (quantidade_venda * Decimal('10')).quantize(Decimal('1'), rounding='ROUND_DOWN') / Decimal('10')

        if quantidade_venda < Decimal('1'):  # M√≠nimo 1 ADA
            logger.warning(f"‚ö†Ô∏è Quantidade ADA abaixo do m√≠nimo: {quantidade_venda} ADA")
            return False

        valor_ordem = quantidade_venda * preco_atual

        # Verificar valor m√≠nimo de ordem ($5.00)
        if valor_ordem < settings.VALOR_MINIMO_ORDEM:
            logger.warning(f"‚ö†Ô∏è Valor de ordem abaixo do m√≠nimo: ${valor_ordem:.2f}")
            return False

        # Verificar se √© venda de seguran√ßa
        eh_venda_seguranca = meta.get('tipo_venda') == 'seguranca'
        zona_seguranca = meta.get('zona_seguranca')

        try:
            # Capturar saldos antes da venda
            saldos_antes = self.obter_saldos()
            preco_medio_antes = self.preco_medio_compra

            # Criar ordem de venda
            ordem = self.api.criar_ordem_mercado(
                simbolo='ADAUSDT',
                lado='SELL',
                quantidade=float(quantidade_venda)
            )

            if ordem and ordem.get('status') == 'FILLED':
                # Calcular lucro real da venda
                valor_medio_compra = quantidade_venda * self.preco_medio_compra
                lucro_real = valor_ordem - valor_medio_compra

                logger.operacao_venda(
                    par='ADA/USDT',
                    quantidade=float(quantidade_venda),
                    preco=float(preco_atual),
                    meta=meta['meta'],
                    lucro_pct=float(lucro_pct),
                    lucro_usd=float(lucro_real)
                )

                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                # SE FOR VENDA DE SEGURAN√áA: Guardar capital para recompra
                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if eh_venda_seguranca and zona_seguranca:
                    nome_zona = zona_seguranca['nome']

                    # Guardar capital obtido e high-water mark atual
                    self.capital_para_recompra[nome_zona] = {
                        'capital_usdt': valor_ordem,  # Capital em USDT obtido da venda
                        'high_water_mark': self.high_water_mark_profit,  # Pico de lucro registrado
                        'gatilho_recompra_pct': Decimal(str(zona_seguranca['gatilho_recompra_drop_pct'])),
                        'quantidade_vendida': quantidade_venda,
                        'preco_venda': preco_atual
                    }

                    # Marcar zona como acionada
                    self.zonas_de_seguranca_acionadas.add(nome_zona)

                    logger.info(f"üí∞ Capital reservado para recompra: ${valor_ordem:.2f} USDT")
                    logger.info(f"   üìå Zona '{nome_zona}' marcada como acionada")
                    logger.info(f"   üîÑ Recompra ser√° ativada se lucro cair {zona_seguranca['gatilho_recompra_drop_pct']}% desde o pico")

                # Ajustar tracking ap√≥s venda (reduzir quantidade total)
                self.quantidade_total_comprada -= quantidade_venda
                self.valor_total_investido -= valor_medio_compra

                # RECALCULAR PRE√áO M√âDIO ap√≥s ajustar valores
                if self.quantidade_total_comprada > 0:
                    self.preco_medio_compra = self.valor_total_investido / self.quantidade_total_comprada
                    logger.info(f"üìä Posi√ß√£o atualizada: {self.quantidade_total_comprada:.1f} ADA (pre√ßo m√©dio: ${self.preco_medio_compra:.6f})")
                else:
                    self.preco_medio_compra = None  # Zerou posi√ß√£o
                    logger.info(f"üìä Posi√ß√£o zerada - todas as ADA vendidas!")

                # Capturar saldos depois da venda
                saldos_depois = self.obter_saldos()

                # SALVAR NO BANCO DE DADOS
                observacao = f"Venda {meta['meta']} - Lucro {lucro_pct:.2f}%"
                if eh_venda_seguranca:
                    observacao = f"Venda de Seguran√ßa '{zona_seguranca['nome']}' - Lucro {lucro_pct:.2f}% (capital reservado para recompra)"

                self.db.registrar_ordem({
                    'tipo': 'VENDA',
                    'par': 'ADA/USDT',
                    'quantidade': quantidade_venda,
                    'preco': preco_atual,
                    'valor_total': valor_ordem,
                    'taxa': ordem.get('fills', [{}])[0].get('commission', 0) if ordem.get('fills') else 0,
                    'meta': meta['meta'],
                    'lucro_percentual': lucro_pct,
                    'lucro_usdt': lucro_real,
                    'preco_medio_antes': preco_medio_antes,
                    'preco_medio_depois': self.preco_medio_compra,
                    'saldo_ada_antes': saldos_antes['ada'],
                    'saldo_ada_depois': saldos_depois['ada'],
                    'saldo_usdt_antes': saldos_antes['usdt'],
                    'saldo_usdt_depois': saldos_depois['usdt'],
                    'order_id': ordem.get('orderId'),
                    'observacao': observacao
                })

                # Atualizar estado do bot no banco
                self.db.atualizar_estado_bot(
                    preco_medio=self.preco_medio_compra,
                    quantidade=self.quantidade_total_comprada
                )

                return True
            else:
                logger.error(f"‚ùå Erro ao executar venda: {ordem}")
                return False

        except Exception as e:
            logger.erro_api('executar_venda', str(e))
            return False

    def verificar_recompra_de_seguranca(self, preco_atual: Decimal):
        """
        Verifica se deve executar recompra ap√≥s venda de seguran√ßa.

        L√ìGICA:
        1. Para cada zona com capital reservado
        2. Calcular lucro atual (se houver posi√ß√£o)
        3. Se lucro caiu o suficiente desde high-water mark, executar recompra
        4. Limpar capital reservado ap√≥s recompra

        Args:
            preco_atual: Pre√ßo atual de ADA/USDT
        """
        if not self.capital_para_recompra:
            return  # Nenhuma recompra pendente

        # Calcular lucro atual (se houver posi√ß√£o)
        lucro_atual = self.calcular_lucro_atual(preco_atual)

        if lucro_atual is None:
            # Sem posi√ß√£o - n√£o faz sentido recomprar sem pre√ßo m√©dio
            return

        zonas_para_remover = []

        for nome_zona, dados_zona in self.capital_para_recompra.items():
            high_mark = dados_zona['high_water_mark']
            gatilho_recompra_pct = dados_zona['gatilho_recompra_pct']
            capital_usdt = dados_zona['capital_usdt']

            # Calcular gatilho de recompra
            gatilho_recompra = high_mark - gatilho_recompra_pct

            # Verificar se lucro atual caiu abaixo do gatilho
            if lucro_atual <= gatilho_recompra:
                logger.info(f"üîÑ GATILHO DE RECOMPRA ATIVADO - Zona '{nome_zona}'")
                logger.info(f"   üìä High-Water Mark: {high_mark:.2f}%")
                logger.info(f"   üìâ Lucro atual: {lucro_atual:.2f}%")
                logger.info(f"   üéØ Gatilho: {gatilho_recompra:.2f}% (queda de {gatilho_recompra_pct:.2f}%)")
                logger.info(f"   üí∞ Capital dispon√≠vel: ${capital_usdt:.2f} USDT")

                # Calcular quantidade de ADA a comprar
                quantidade_ada = capital_usdt / preco_atual

                # Arredondar para 0.1 (step size ADA)
                quantidade_ada = (quantidade_ada * Decimal('10')).quantize(
                    Decimal('1'), rounding='ROUND_DOWN'
                ) / Decimal('10')

                valor_ordem = quantidade_ada * preco_atual

                # Validar valor m√≠nimo
                if valor_ordem >= settings.VALOR_MINIMO_ORDEM and quantidade_ada >= Decimal('1'):
                    # Executar recompra
                    sucesso = self._executar_recompra(
                        nome_zona=nome_zona,
                        quantidade_ada=quantidade_ada,
                        preco_atual=preco_atual,
                        capital_usado=valor_ordem,
                        dados_zona=dados_zona
                    )

                    if sucesso:
                        # Marcar zona para remo√ß√£o
                        zonas_para_remover.append(nome_zona)
                else:
                    logger.warning(f"‚ö†Ô∏è Recompra ignorada - valor abaixo do m√≠nimo: ${valor_ordem:.2f}")
                    zonas_para_remover.append(nome_zona)

        # Remover zonas que foram recompradas
        for nome_zona in zonas_para_remover:
            del self.capital_para_recompra[nome_zona]
            logger.debug(f"‚úÖ Capital de zona '{nome_zona}' removido ap√≥s recompra")

    def _executar_recompra(self, nome_zona: str, quantidade_ada: Decimal, preco_atual: Decimal,
                          capital_usado: Decimal, dados_zona: Dict) -> bool:
        """
        Executa ordem de recompra ap√≥s venda de seguran√ßa.

        Args:
            nome_zona: Nome da zona de seguran√ßa
            quantidade_ada: Quantidade de ADA a comprar
            preco_atual: Pre√ßo atual de ADA
            capital_usado: Capital USDT a ser usado
            dados_zona: Dados da zona (high_mark, preco_venda, etc)

        Returns:
            True se recompra foi executada com sucesso, False caso contr√°rio
        """
        try:
            # Capturar saldos antes da recompra
            saldos_antes = self.obter_saldos()
            preco_medio_antes = self.preco_medio_compra

            # Criar ordem de compra
            ordem = self.api.criar_ordem_mercado(
                simbolo='ADAUSDT',
                lado='BUY',
                quantidade=float(quantidade_ada)
            )

            if ordem and ordem.get('status') == 'FILLED':
                # Comparar com venda original
                preco_venda_original = dados_zona['preco_venda']
                diferenca_preco = ((preco_atual - preco_venda_original) / preco_venda_original) * Decimal('100')

                logger.operacao_compra(
                    par='ADA/USDT',
                    quantidade=float(quantidade_ada),
                    preco=float(preco_atual),
                    degrau=f"recompra_{nome_zona}",
                    queda_pct=float(diferenca_preco)
                )

                logger.info(f"‚úÖ RECOMPRA DE SEGURAN√áA EXECUTADA!")
                logger.info(f"   üì¶ Comprado: {float(quantidade_ada):.1f} ADA por ${preco_atual:.6f}")
                logger.info(f"   üíµ Custo: ${capital_usado:.2f} USDT")
                logger.info(f"   üìä Pre√ßo venda original: ${preco_venda_original:.6f}")
                logger.info(f"   üìà Diferen√ßa: {diferenca_preco:+.2f}%")

                # Atualizar pre√ßo m√©dio de compra
                self.atualizar_preco_medio_compra(quantidade_ada, preco_atual)

                # Capturar saldos depois da recompra
                saldos_depois = self.obter_saldos()

                # SALVAR NO BANCO DE DADOS
                self.db.registrar_ordem({
                    'tipo': 'COMPRA',
                    'par': 'ADA/USDT',
                    'quantidade': quantidade_ada,
                    'preco': preco_atual,
                    'valor_total': capital_usado,
                    'taxa': ordem.get('fills', [{}])[0].get('commission', 0) if ordem.get('fills') else 0,
                    'meta': f'recompra_seguranca_{nome_zona}',
                    'preco_medio_antes': preco_medio_antes,
                    'preco_medio_depois': self.preco_medio_compra,
                    'saldo_ada_antes': saldos_antes['ada'],
                    'saldo_ada_depois': saldos_depois['ada'],
                    'saldo_usdt_antes': saldos_antes['usdt'],
                    'saldo_usdt_depois': saldos_depois['usdt'],
                    'order_id': ordem.get('orderId'),
                    'observacao': f"Recompra de Seguran√ßa zona '{nome_zona}' - Diferen√ßa {diferenca_preco:+.2f}% vs venda original"
                })

                # Atualizar estado do bot no banco
                self.db.atualizar_estado_bot(
                    preco_medio=self.preco_medio_compra,
                    quantidade=self.quantidade_total_comprada
                )

                return True
            else:
                logger.error(f"‚ùå Erro ao executar recompra: {ordem}")
                return False

        except Exception as e:
            logger.erro_api('_executar_recompra', str(e))
            return False

    def _verificar_aportes_brl(self):
        """Verifica novos aportes em BRL e os converte para USDT."""
        try:
            logger.info("üîç Verificando poss√≠veis aportes em BRL...")
            resultado = self.gerenciador_aportes.processar_aporte_automatico()

            if resultado.get('sucesso'):
                logger.info(f"‚úÖ Aporte processado: {resultado.get('mensagem')}")
                # For√ßar a sincroniza√ß√£o de saldos para atualizar o capital do bot
                logger.info("üîÑ For√ßando a sincroniza√ß√£o de saldos ap√≥s o aporte...")
                self._sincronizar_saldos_binance()
            else:
                # Logar apenas se a mensagem n√£o for de saldo insuficiente, para evitar spam
                if "insuficiente" not in resultado.get('mensagem', ""):
                    logger.info(f"‚ÑπÔ∏è Nenhum novo aporte detectado. {resultado.get('mensagem')}")

        except Exception as e:
            logger.error(f"‚ùå Erro ao verificar aportes BRL: {e}")


    def fazer_backup_periodico(self):
        """Faz backup do banco de dados periodicamente (1x por dia)"""
        agora = datetime.now()
        intervalo = timedelta(days=1)

        if agora - self.ultimo_backup >= intervalo:
            try:
                logger.info("üíæ Criando backup do banco de dados...")
                backup_path = self.db.fazer_backup()
                logger.info(f"‚úÖ Backup criado: {backup_path}")
                self.ultimo_backup = agora
            except Exception as e:
                logger.error(f"‚ùå Erro ao criar backup: {e}")

    def _calcular_volatilidade_mercado(self, preco_atual: Decimal) -> tuple[Decimal, str]:
        """
        Calcula volatilidade do mercado na √∫ltima hora.

        Returns:
            Tuple (variacao_pct, classificacao)
            classificacao: 'Alta', 'M√©dia', 'Baixa'
        """
        if len(self.historico_precos) < 2:
            return (Decimal('0'), 'Baixa')

        # Pegar pre√ßos da √∫ltima hora (12 pre√ßos a cada 5 segundos = √∫ltimos 60 segundos)
        precos_recentes = list(self.historico_precos)[-12:]

        if len(precos_recentes) < 2:
            return (Decimal('0'), 'Baixa')

        preco_min = min(precos_recentes)
        preco_max = max(precos_recentes)

        if preco_min == 0:
            return (Decimal('0'), 'Baixa')

        variacao_pct = ((preco_max - preco_min) / preco_min) * Decimal('100')

        # Classificar volatilidade
        if variacao_pct >= Decimal('2.0'):
            classificacao = 'Alta'
        elif variacao_pct >= Decimal('0.5'):
            classificacao = 'M√©dia'
        else:
            classificacao = 'Baixa'

        return (variacao_pct, classificacao)

    def _obter_proxima_meta(self, lucro_atual_pct: Optional[Decimal]) -> tuple[str, Decimal]:
        """
        Identifica a pr√≥xima meta de venda fixa a ser atingida.

        Args:
            lucro_atual_pct: Lucro percentual atual (ou None se sem posi√ß√£o)

        Returns:
            Tuple (nome_meta, distancia_pct)
            Ex: ("Venda Fixa 1 (6.0%)", Decimal('2.5'))
        """
        from config.settings import settings

        if lucro_atual_pct is None:
            # Sem posi√ß√£o - pr√≥xima meta √© a primeira
            primeira_meta = min(settings.METAS_VENDA, key=lambda x: x['lucro_percentual'])
            meta_pct = Decimal(str(primeira_meta['lucro_percentual']))
            return (f"{primeira_meta['meta']} ({meta_pct}%)", meta_pct)

        # Com posi√ß√£o - encontrar pr√≥xima meta n√£o atingida
        metas_ordenadas = sorted(settings.METAS_VENDA, key=lambda x: x['lucro_percentual'])

        for meta in metas_ordenadas:
            meta_pct = Decimal(str(meta['lucro_percentual']))
            if lucro_atual_pct < meta_pct:
                distancia = meta_pct - lucro_atual_pct
                return (f"{meta['meta']} ({meta_pct}%)", distancia)

        # Todas as metas j√° atingidas
        ultima_meta = max(settings.METAS_VENDA, key=lambda x: x['lucro_percentual'])
        meta_pct = Decimal(str(ultima_meta['lucro_percentual']))
        return (f"{ultima_meta['meta']} ({meta_pct}%)", Decimal('0'))

    def _obter_estado_bot(self) -> str:
        """
        Retorna string descritiva do estado atual do bot.

        Returns:
            String com estado atual (ex: "Acumulando", "Aguardando Meta", etc.)
        """
        # Verificar se tem capital reservado para recompra
        if self.capital_para_recompra:
            zonas = list(self.capital_para_recompra.keys())
            return f"Aguardando Recompra ({', '.join(zonas)})"

        # Verificar se est√° aguardando saldo
        if self.estado_bot == "AGUARDANDO_SALDO":
            return "Sem Saldo | Aguardando Venda/Aporte"

        # Verificar se tem posi√ß√£o
        if self.quantidade_total_comprada > 0:
            # Com posi√ß√£o - aguardando meta
            return "Acumulando | Aguardando Meta de Lucro"
        else:
            # Sem posi√ß√£o - aguardando compra
            return "Sem Posi√ß√£o | Aguardando Degrau"

    def _formatar_tempo_relativo(self, timestamp_str: str) -> str:
        """
        Converte timestamp ISO para formato relativo (ex: "h√° 3h", "h√° 15m").

        Args:
            timestamp_str: Timestamp no formato ISO

        Returns:
            String com tempo relativo
        """
        try:
            timestamp = datetime.fromisoformat(timestamp_str)
            agora = datetime.now()
            delta = agora - timestamp

            # Calcular componentes
            dias = delta.days
            horas = delta.seconds // 3600
            minutos = (delta.seconds % 3600) // 60

            if dias > 0:
                return f"h√° {dias}d{horas}h"
            elif horas > 0:
                return f"h√° {horas}h"
            elif minutos > 0:
                return f"h√° {minutos}m"
            else:
                return "agora"

        except Exception:
            return "N/A"

    def logar_painel_de_status(self, preco_atual: Decimal, saldos: Dict):
        """
        Loga painel avan√ßado de status do bot com informa√ß√µes t√°ticas.

        O painel √© constru√≠do como uma √∫nica string para preservar formata√ß√£o.

        Args:
            preco_atual: Pre√ßo atual de ADA
            saldos: Dicion√°rio com saldos USDT e ADA
        """
        try:
            # Calcular m√©tricas b√°sicas
            valor_posicao = self.quantidade_total_comprada * preco_atual if self.quantidade_total_comprada > 0 else Decimal('0')
            self.gestao_capital.atualizar_saldos(saldos['usdt'], valor_posicao)
            capital_total = self.gestao_capital.calcular_capital_total()

            # Calcular lucro atual
            lucro_pct = self.calcular_lucro_atual(preco_atual) if self.preco_medio_compra else None
            if lucro_pct and self.quantidade_total_comprada > 0:
                lucro_usdt = (preco_atual - self.preco_medio_compra) * self.quantidade_total_comprada
            else:
                lucro_usdt = Decimal('0')

            # Calcular aloca√ß√£o de capital
            if capital_total > 0:
                pct_ada = (valor_posicao / capital_total) * Decimal('100')
                pct_usdt = Decimal('100') - pct_ada
            else:
                pct_ada = Decimal('0')
                pct_usdt = Decimal('100')

            # Obter volatilidade
            volatilidade_pct, volatilidade_classe = self._calcular_volatilidade_mercado(preco_atual)

            # Obter √∫ltima compra e venda
            ultima_compra = self.db.obter_ultima_ordem('COMPRA')
            ultima_venda = self.db.obter_ultima_ordem('VENDA')

            # Obter pr√≥xima meta
            nome_meta, distancia_meta = self._obter_proxima_meta(lucro_pct)

            # Obter estado do bot
            estado = self._obter_estado_bot()

            # Calcular uptime
            agora = datetime.now()
            uptime_delta = agora - self.inicio_bot
            uptime_horas = int(uptime_delta.total_seconds() / 3600)
            uptime_minutos = int((uptime_delta.total_seconds() % 3600) / 60)
            hora_atual = agora.strftime('%H:%M:%S')

            # Formatar uptime
            uptime_str = f"{uptime_horas}h {uptime_minutos}m"

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # Construir linha de POSI√á√ÉO
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if self.quantidade_total_comprada > 0 and self.preco_medio_compra:
                linha_posicao = f"‚îÇ üíº POSI√á√ÉO ‚îÇ {self.quantidade_total_comprada:.1f} ADA @ ${self.preco_medio_compra:.4f} | L/P: {lucro_pct:+.2f}% (${lucro_usdt:+.2f})      ‚îÇ"
            else:
                linha_posicao = "‚îÇ üíº POSI√á√ÉO ‚îÇ Sem posi√ß√£o aberta                           ‚îÇ"

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # Construir linha de COMPRA
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if ultima_compra:
                tempo_compra = self._formatar_tempo_relativo(ultima_compra['timestamp'])
                qtd_compra = float(ultima_compra['quantidade'])
                preco_compra = float(ultima_compra['preco'])
                valor_compra = float(ultima_compra['valor_total'])
                linha_compra = f"‚îÇ üü¢ COMPRA ‚îÇ {qtd_compra:.1f} ADA @ ${preco_compra:.4f} ({tempo_compra}) ‚îÇ Total: ${valor_compra:.2f}       ‚îÇ"
            else:
                linha_compra = "‚îÇ üü¢ COMPRA ‚îÇ Nenhuma compra registrada                    ‚îÇ"

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # Construir linha de VENDA (com encurtamento de nome)
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if ultima_venda:
                tempo_venda = self._formatar_tempo_relativo(ultima_venda['timestamp'])
                qtd_venda = float(ultima_venda['quantidade'])
                preco_venda = float(ultima_venda['preco'])
                lucro_venda = float(ultima_venda.get('lucro_usdt', 0))
                meta_venda = ultima_venda.get('meta', 'N/A')

                # Encurtar nome da meta de seguran√ßa
                # De: seguranca_Seguranca_Pre-Meta1-A
                # Para: Seg: Pre-Meta1-A
                if meta_venda.startswith('seguranca_'):
                    # Remover prefixo 'seguranca_' e 'Seguranca_'
                    meta_venda_curta = meta_venda.replace('seguranca_', '')
                    meta_venda_curta = meta_venda_curta.replace('Seguranca_', '')
                    meta_venda_curta = f"Seg: {meta_venda_curta}"
                else:
                    meta_venda_curta = meta_venda

                linha_venda = f"‚îÇ üî¥ VENDA  ‚îÇ {qtd_venda:.1f} ADA @ ${preco_venda:.4f} ({tempo_venda}) ‚îÇ Lucro: ${lucro_venda:.2f} ({meta_venda_curta})‚îÇ"
            else:
                linha_venda = "‚îÇ üî¥ VENDA  ‚îÇ Nenhuma venda registrada                     ‚îÇ"

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # Montar painel como UMA √öNICA STRING
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            painel = f"""
‚îå‚îÄ üìä BOT STATUS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ {hora_atual} | Uptime: {uptime_str} ‚îÄ‚îê
‚îÇ üìà MERCADO ‚îÇ ${preco_atual:.4f} ‚îÇ Volatilidade (1h): {volatilidade_pct:+.2f}% ({volatilidade_classe})    ‚îÇ
{linha_posicao}
‚îÇ üí∞ CAPITAL ‚îÇ Total: ${capital_total:.2f} ‚îÇ Aloca√ß√£o: [{pct_ada:.0f}% ADA|{pct_usdt:.0f}% USDT] ‚îÇ
‚îú‚îÄ √öLTIMAS OPERA√á√ïES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
{linha_compra}
{linha_venda}
‚îú‚îÄ ESTRAT√âGIA ATUAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üéØ PR√ìXIMA META ‚îÇ {nome_meta:20s} ‚îÇ Faltam: {distancia_meta:+.2f}%                 ‚îÇ
‚îÇ üß† ESTADO       ‚îÇ {estado:50s} ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

            # Logar como uma √∫nica string (preserva formata√ß√£o)
            logger.info(painel)

        except Exception as e:
            logger.error(f"‚ùå Erro ao gerar painel de status: {e}")

    def loop_principal(self):
        """Loop principal do bot"""
        logger.banner("ü§ñ BOT DE TRADING INICIADO")
        logger.info(f"Par: {settings.PAR_PRINCIPAL}")
        logger.info(f"Ambiente: {settings.AMBIENTE}")
        logger.info(f"Capital inicial: ${settings.CAPITAL_INICIAL}")

        # Verificar conex√£o
        if not self.api.verificar_conexao():
            logger.error("‚ùå N√£o foi poss√≠vel conectar √† API Binance")
            return

        logger.info("‚úÖ Conectado √† Binance")

        # CR√çTICO: Sincronizar saldo real da Binance com backup local
        # Isso garante que diverg√™ncias (compras/vendas manuais) sejam detectadas
        self._sincronizar_saldos_binance()

        # Calcular SMA de refer√™ncia (4 semanas)
        logger.info("üìä Calculando SMA de refer√™ncia (4 semanas)...")
        self.atualizar_sma()

        if not self.sma_referencia:
            logger.error("‚ùå N√£o foi poss√≠vel calcular SMA. Bot n√£o pode operar.")
            return

        # Obter pre√ßo inicial
        preco_inicial = self.obter_preco_atual()
        if preco_inicial:
            logger.info(f"üìä Pre√ßo inicial ADA: ${preco_inicial:.6f}")
            queda_inicial = self.calcular_queda_percentual(preco_inicial)
            if queda_inicial is not None:
                logger.info(f"üìâ Dist√¢ncia da SMA: {queda_inicial:.2f}%")

        self.rodando = True
        contador_ciclos = 0

        try:
            while self.rodando:
                contador_ciclos += 1

                # Obter pre√ßo atual
                preco_atual = self.obter_preco_atual()
                if not preco_atual:
                    logger.warning("‚ö†Ô∏è N√£o foi poss√≠vel obter pre√ßo, aguardando...")
                    time.sleep(10)
                    continue

                # Atualizar SMA periodicamente (a cada 1 hora)
                self.atualizar_sma()

                # Calcular queda desde SMA
                queda_pct = self.calcular_queda_percentual(preco_atual)

                # Log a cada 10 ciclos (aproximadamente 1 minuto)
                if contador_ciclos % 10 == 0:
                    if queda_pct and self.sma_referencia:
                        logger.info(f"üìä Pre√ßo: ${preco_atual:.6f} | SMA 4sem: ${self.sma_referencia:.6f} | Dist√¢ncia: {queda_pct:.2f}%")
                    else:
                        logger.info(f"üìä Pre√ßo: ${preco_atual:.6f}")

                # Obter saldos atuais
                saldos = self.obter_saldos()

                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                # VERIFICA√á√ÉO DE SALDO DISPON√çVEL (Modo "Aguardando Saldo")
                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                # Calcular saldo dispon√≠vel considerando reserva
                valor_posicao = self.quantidade_total_comprada * preco_atual if self.quantidade_total_comprada > 0 else Decimal('0')

                # Usar GestaoCapital para calcular reserva e capital dispon√≠vel
                self.gestao_capital.atualizar_saldos(saldos['usdt'], valor_posicao)
                reserva = self.gestao_capital.calcular_reserva_obrigatoria()
                capital_total = self.gestao_capital.calcular_capital_total()
                saldo_disponivel = self.gestao_capital.calcular_capital_disponivel()
                valor_minimo_operar = Decimal('10.00')  # M√≠nimo para tentar compras

                if saldo_disponivel < valor_minimo_operar:
                    # SEM SALDO SUFICIENTE - Entrar em modo "Aguardando Saldo"
                    if self.estado_bot != "AGUARDANDO_SALDO":
                        self.estado_bot = "AGUARDANDO_SALDO"
                        logger.warning("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                        logger.warning("‚è∏Ô∏è  BOT EM MODO 'AGUARDANDO SALDO'")
                        logger.warning("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                        logger.warning(f"   üí∞ Saldo dispon√≠vel: ${saldo_disponivel:.2f}")
                        logger.warning(f"   ‚ö†Ô∏è  M√≠nimo necess√°rio: ${valor_minimo_operar:.2f}")
                        logger.warning(f"   üõ°Ô∏è  Reserva protegida: ${reserva:.2f}")
                        logger.warning("")
                        logger.warning("   üìå Bot pausou verifica√ß√µes de degraus")
                        logger.warning("   üìå Aguardando venda ou novo aporte para retomar")
                        logger.warning("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")

                    # N√ÉO verificar degraus de compra - pular para l√≥gica de venda
                    # (Vendas ainda s√£o permitidas para liberar saldo)
                else:
                    # TEM SALDO SUFICIENTE - Sair de modo "Aguardando Saldo" se estava nele
                    if self.estado_bot == "AGUARDANDO_SALDO":
                        self.estado_bot = "OPERANDO"
                        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                        logger.info("‚úÖ SALDO RESTAURADO - Bot retomando opera√ß√µes")
                        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                        logger.info(f"   üí∞ Saldo dispon√≠vel: ${saldo_disponivel:.2f}")
                        logger.info(f"   üõ°Ô∏è  Reserva mantida: ${reserva:.2f}")
                        logger.info("")
                        logger.info("   ‚úÖ Verifica√ß√µes de degraus reativadas")
                        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")

                # L√ìGICA DE COMPRA (s√≥ executa se estado == "OPERANDO")
                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if self.estado_bot == "OPERANDO" and queda_pct and queda_pct > Decimal('0.5'):
                    # üõ°Ô∏è GUARDI√ÉO DE GEST√ÉO DE RISCO üõ°Ô∏è
                    # Verifica a exposi√ß√£o antes de qualquer tentativa de compra
                    alocacao_atual_ada = self.gestao_capital.get_alocacao_percentual_ada()
                    limite_exposicao = Decimal(str(settings.GESTAO_DE_RISCO['exposicao_maxima_percentual_capital']))

                    if alocacao_atual_ada > limite_exposicao:
                        if not self.notificou_exposicao_maxima:
                            logger.warning("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                            logger.warning(f"üõ°Ô∏è GUARDI√ÉO ATIVADO: Exposi√ß√£o m√°xima de {limite_exposicao}% atingida.")
                            logger.warning(f"   Aloca√ß√£o atual em ADA: {alocacao_atual_ada:.1f}%")
                            logger.warning("   Compras normais suspensas. Verificando camadas de oportunidade extrema...")
                            logger.warning("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                            self.notificou_exposicao_maxima = True

                        # L√≥gica de Compras em Camadas para Oportunidades Extremas
                        oportunidades_usadas = self.state.get_state('oportunidades_extremas_usadas', default=[])
                        camadas_oportunidade = settings.GESTAO_DE_RISCO['compras_de_oportunidade_extrema']

                        for camada in camadas_oportunidade:
                            preco_alvo = Decimal(str(camada['preco_alvo']))

                            if preco_atual <= preco_alvo and str(preco_alvo) not in oportunidades_usadas:
                                logger.info(f"üö® OPORTUNIDADE EXTREMA (Camada {preco_alvo}) DETECTADA!")

                                percentual_a_usar = Decimal(str(camada['percentual_capital_usar']))
                                capital_disponivel = self.gestao_capital.calcular_capital_disponivel()
                                valor_da_compra_usdt = capital_disponivel * (percentual_a_usar / Decimal('100'))

                                sucesso = self.executar_compra_por_valor(valor_da_compra_usdt, f"Oportunidade Extrema {preco_alvo}")

                                if sucesso:
                                    oportunidades_usadas.append(str(preco_alvo))
                                    self.state.set_state('oportunidades_extremas_usadas', oportunidades_usadas)
                                
                                return # Sai ap√≥s tratar a primeira oportunidade v√°lida

                        # Se o loop terminar, nenhuma camada foi ativada
                        logger.debug(f"üõ°Ô∏è Exposi√ß√£o m√°xima atingida. Nenhuma nova camada de oportunidade ativada.")

                    else:
                        # Se a exposi√ß√£o voltar ao normal, reativa as notifica√ß√µes e a l√≥gica de compra
                        if self.notificou_exposicao_maxima:
                            logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                            logger.info(f"‚úÖ Exposi√ß√£o de capital normalizada ({alocacao_atual_ada:.1f}%). Compras normais reativadas.")
                            logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                            self.notificou_exposicao_maxima = False
                        
                        # Limpa o estado das oportunidades usadas quando a exposi√ß√£o √© normalizada
                        if self.state.get_state('oportunidades_extremas_usadas'):
                            self.state.set_state('oportunidades_extremas_usadas', [])
                            logger.info("üîì Camadas de oportunidade extrema rearmadas.")

                        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        # ESTRAT√âGIA: LARGADA A FRIO
                        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        if self.primeira_execucao:
                            # Encontrar degrau MAIS PROFUNDO ativado
                            degrau_profundo = self.encontrar_degrau_mais_profundo(queda_pct)

                            if degrau_profundo:
                                logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                                logger.info("ü•∂ LARGADA A FRIO DETECTADA!")
                                logger.info(f"   Queda desde SMA: {queda_pct:.2f}%")
                                logger.info(f"   Degrau mais profundo ativado: N√≠vel {degrau_profundo['nivel']}")
                                logger.info(f"   Executando compra controlada no degrau {degrau_profundo['nivel']}")
                                logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")

                                # CORRE√á√ÉO CR√çTICA: Marcar como tratada ANTES da compra
                                # Isso evita loop infinito se a compra falhar por falta de capital
                                self.primeira_execucao = False

                                # Persistir estado no StateManager
                                self.state.set_state('cold_start_executado_ts', datetime.now().isoformat())

                                # Executar APENAS UMA compra no degrau mais profundo
                                if self.executar_compra(degrau_profundo, preco_atual, saldos['usdt']):
                                    logger.info("‚úÖ Compra de 'Largada a Frio' executada!")
                                    logger.info("   üïí Cooldown global ativado")
                                    compra_executada = True

                                    # Aguardar 10 segundos ap√≥s compra
                                    time.sleep(10)
                                else:
                                    logger.info("‚ö†Ô∏è Compra de 'Largada a Frio' n√£o executada (sem capital dispon√≠vel)")
                                    logger.info("   Bot continuar√° em modo normal")
                            else:
                                # Nenhum degrau ativado - continuar normalmente
                                self.primeira_execucao = False
                                logger.debug("Primeira execu√ß√£o, mas nenhum degrau ativado")

                        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        # ESTRAT√âGIA NORMAL: Tentar comprar em degraus com cooldown duplo
                        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        if not compra_executada and not self.primeira_execucao:
                            for degrau in settings.DEGRAUS_COMPRA:
                                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                                # DUPLA-CONDI√á√ÉO: Verificar SMA + Pre√ßo M√©dio
                                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                                # CONDI√á√ÉO 1: Verificar se degrau est√° ativo (queda suficiente desde SMA)
                                condicao_sma_ok = queda_pct >= Decimal(str(degrau['queda_percentual']))

                                # CONDI√á√ÉO 2: Verificar se pre√ßo melhora o pre√ßo m√©dio (DCA inteligente)
                                condicao_melhora_pm_ok = True  # Default: permite compra

                                if self.preco_medio_compra is not None and self.preco_medio_compra > 0:
                                    # Se j√° tem posi√ß√£o, verificar se pre√ßo atual melhora o pre√ßo m√©dio
                                    percentual_melhora = settings.PERCENTUAL_MINIMO_MELHORA_PM / Decimal('100')
                                    limite_preco_melhora = self.preco_medio_compra * (Decimal('1') - percentual_melhora)
                                    condicao_melhora_pm_ok = preco_atual <= limite_preco_melhora

                                # Verificar se AMBAS as condi√ß√µes foram atendidas
                                if condicao_sma_ok and condicao_melhora_pm_ok:
                                    nivel_degrau = degrau['nivel']

                                    # Verificar se pode comprar (cooldown duplo)
                                    pode_comprar, motivo_bloqueio = self.pode_comprar_degrau(nivel_degrau, degrau)

                                    if pode_comprar:
                                        # DESBLOQUEADO: Remover do set se estava bloqueado
                                        if nivel_degrau in self.degraus_notificados_bloqueados:
                                            self.degraus_notificados_bloqueados.remove(nivel_degrau)
                                            logger.info(f"üîì Degrau {nivel_degrau} desbloqueado")

                                        # ANTI-SPAM: S√≥ loga "Degrau X ativado" 1x a cada 5 minutos
                                        agora = datetime.now()
                                        ultima_log = self.ultima_tentativa_log_degrau.get(nivel_degrau)

                                        if ultima_log is None or (agora - ultima_log) >= timedelta(minutes=5):
                                            logger.info(f"üéØ Degrau {nivel_degrau} ativado! Queda: {queda_pct:.2f}%")
                                            self.ultima_tentativa_log_degrau[nivel_degrau] = agora

                                        # Tentar executar compra
                                        if self.executar_compra(degrau, preco_atual, saldos['usdt']):
                                            logger.info("‚úÖ Compra executada com sucesso!")
                                            compra_executada = True

                                            # Aguardar 10 segundos ap√≥s compra
                                            time.sleep(10)
                                            break  # Compra executada, sair do loop
                                    else:
                                        # BLOQUEADO: Notificar apenas uma vez
                                        if nivel_degrau not in self.degraus_notificados_bloqueados:
                                            self.degraus_notificados_bloqueados.add(nivel_degrau)
                                            if motivo_bloqueio and motivo_bloqueio.startswith('cooldown_global'):
                                                logger.debug(f"üïí Cooldown global ativo ({motivo_bloqueio})")
                                            elif motivo_bloqueio and motivo_bloqueio.startswith('cooldown_degrau'):
                                                logger.debug(f"üïí Degrau {nivel_degrau} em cooldown ({motivo_bloqueio})")

                                    # Se n√£o pode comprar neste degrau (cooldown), tenta o pr√≥ximo
                                else:
                                    # Uma das condi√ß√µes n√£o foi atendida - ignorar degrau
                                    if condicao_sma_ok and not condicao_melhora_pm_ok:
                                        # Degrau ativo pela SMA, mas pre√ßo n√£o melhora suficiente o PM
                                        logger.debug(
                                            f"üìä Degrau {degrau['nivel']}: SMA OK ({queda_pct:.2f}%), mas pre√ßo ${preco_atual:.6f} "
                                            f"n√£o melhora PM (${self.preco_medio_compra:.6f}) em {settings.PERCENTUAL_MINIMO_MELHORA_PM}%"
                                        )

                # L√ìGICA DE VENDA (s√≥ vende com lucro!)
                if self.preco_medio_compra and saldos['ada'] >= Decimal('1'):
                    # Calcular lucro atual
                    lucro_atual = self.calcular_lucro_atual(preco_atual)

                    if lucro_atual and lucro_atual > 0:
                        # Buscar meta de venda ativa (passando saldo e pre√ßo para valida√ß√£o)
                        meta = self.encontrar_meta_ativa(lucro_atual, saldos['ada'], preco_atual)

                        if meta:
                            logger.info(f"üéØ Meta {meta['meta']} atingida! Lucro: +{lucro_atual:.2f}%")

                            # Tentar executar venda
                            if self.executar_venda(meta, preco_atual, saldos['ada']):
                                logger.info("‚úÖ Venda executada com lucro!")

                                # Aguardar 10 segundos ap√≥s venda
                                time.sleep(10)
                    else:
                        # Log informativo a cada 20 ciclos (‚âà 2 minutos) quando n√£o h√° lucro
                        if contador_ciclos % 20 == 0 and lucro_atual is not None:
                            logger.info(f"üõ°Ô∏è Aguardando lucro (atual: {lucro_atual:+.2f}% | pre√ßo m√©dio: ${self.preco_medio_compra:.6f})")

                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                # VERIFICAR RECOMPRAS DE SEGURAN√áA
                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                # Se houver capital reservado para recompra, verificar se deve executar
                if self.capital_para_recompra and self.preco_medio_compra:
                    self.verificar_recompra_de_seguranca(preco_atual)

                # Verificar aportes BRL periodicamente
                agora = datetime.now()
                if agora - self.ultima_verificacao_aportes >= self.intervalo_verificacao_aportes:
                    self._verificar_aportes_brl()
                    self.ultima_verificacao_aportes = agora

                # Verificar e comprar BNB para desconto em taxas (1x por dia)
                if saldos['usdt'] >= Decimal('5.0'):
                    resultado_bnb = self.gerenciador_bnb.verificar_e_comprar_bnb(saldos['usdt'])
                    if resultado_bnb.get('sucesso') and resultado_bnb.get('precisa_comprar'):
                        logger.info(f"üíé BNB: {resultado_bnb['mensagem']}")

                # Fazer backup do banco de dados (1x por dia)
                self.fazer_backup_periodico()

                # PAINEL DE STATUS AVAN√áADO
                # Exibir painel periodicamente (a cada 5 minutos ou 60 ciclos)
                if contador_ciclos % 60 == 0:
                    self.logar_painel_de_status(preco_atual, saldos)

                # Aguardar 5 segundos antes do pr√≥ximo ciclo
                time.sleep(5)

        except KeyboardInterrupt:
            logger.warning("\n‚ö†Ô∏è Bot interrompido pelo usu√°rio")
            self.rodando = False
        except Exception as e:
            logger.error(f"‚ùå Erro fatal no loop principal: {e}")
            logger.exception("Traceback:")
            self.rodando = False

        logger.banner("üõë BOT FINALIZADO")


def main():
    """Fun√ß√£o principal"""
    bot = TradingBot()
    bot.loop_principal()


if __name__ == '__main__':
    main()
