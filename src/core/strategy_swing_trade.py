#!/usr/bin/env python3
"""
Strategy Swing Trade - Estrat√©gia de Giro R√°pido (RSI + Stop Promovido)
Focada em capitalizar oscila√ß√µes r√°pidas com prote√ß√£o inteligente de Stop Loss
"""

from decimal import Decimal
from typing import Optional, Dict, Any
from pathlib import Path
import sys

# Adicionar path do projeto
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from src.core.position_manager import PositionManager
from src.core.gestao_capital import GestaoCapital
from src.core.analise_tecnica import AnaliseTecnica


class StrategySwingTrade:
    """
    Estrat√©gia de Swing Trade (Giro R√°pido) - Vers√£o 2.0

    Caracter√≠sticas:
    - Opera com capital separado da carteira de acumula√ß√£o
    - Entrada: RSI < 30 (sobrevenda)
    - Sa√≠da: Sistema "Stop Promovido"
      * Fase 1: Stop Loss inicial (prote√ß√£o)
      * Fase 2: Promo√ß√£o para Trailing Stop quando atinge breakeven (0%)
      * Fase 3: TSL segue o pre√ßo com dist√¢ncia configurada

    Regras:
    - Compra: RSI cai abaixo do limite configurado
    - Venda: Stop Loss disparado OU Trailing Stop disparado
    - Prote√ß√£o: Stop promovido de SL ‚Üí TSL no ponto de breakeven
    """

    def __init__(
        self,
        config: Dict[str, Any],
        position_manager: PositionManager,
        gestao_capital: GestaoCapital,
        analise_tecnica: AnaliseTecnica,
        logger=None,
        notifier=None,
        exchange_api=None
    ):
        """
        Inicializa a estrat√©gia de swing trade

        Args:
            config: Configura√ß√£o completa do bot
            position_manager: Gerenciador de posi√ß√µes
            gestao_capital: Gerenciador de capital
            analise_tecnica: Calculador de indicadores t√©cnicos
            logger: Logger contextual (opcional)
            notifier: Inst√¢ncia do Notifier para notifica√ß√µes
            exchange_api: API da exchange para buscar dados (opcional)
        """
        # Logger contextual (fallback para logger global se n√£o fornecido)
        if logger:
            self.logger = logger
        else:
            from src.utils.logger import get_loggers
            self.logger, _ = get_loggers()

        self.config = config
        self.position_manager = position_manager
        self.gestao_capital = gestao_capital
        self.analise_tecnica = analise_tecnica
        self.notifier = notifier
        self.exchange_api = exchange_api

        # Verifica√ß√£o de habilita√ß√£o da estrat√©gia
        self.habilitado = bool(config.get('ESTRATEGIAS', {}).get('giro_rapido', False))

        if not self.habilitado:
            return

        # Configura√ß√£o da estrat√©gia
        self.estrategia_config = config.get('estrategia_giro_rapido', {})

        # Par√¢metros de aloca√ß√£o
        self.alocacao_capital_pct = Decimal(str(self.estrategia_config.get('alocacao_capital_pct', 20)))

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # PAR√ÇMETROS DE ENTRADA (RSI)
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        self.usar_filtro_rsi_entrada = self.estrategia_config.get('usar_filtro_rsi_entrada', True)
        self.rsi_timeframe_entrada = self.estrategia_config.get('rsi_timeframe_entrada', '15m')
        self.rsi_limite_compra = Decimal(str(self.estrategia_config.get('rsi_limite_compra', 30)))

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # PAR√ÇMETROS DE SA√çDA (Stop Promovido)
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        self.stop_loss_inicial_pct = Decimal(str(self.estrategia_config.get('stop_loss_inicial_pct', 2.5)))
        self.trailing_stop_distancia_pct = Decimal(str(self.estrategia_config.get('trailing_stop_distancia_pct', 0.8)))

        # Estado interno
        self.ultima_compra_timestamp: Optional[float] = None
        self.cooldown_segundos: int = self.estrategia_config.get('cooldown_compra_segundos', 60)
        self.ultima_log_status: Optional[float] = None

        # Configurar aloca√ß√£o na gest√£o de capital
        self.gestao_capital.configurar_alocacao_giro_rapido(self.alocacao_capital_pct)

        self.logger.info(f"‚úÖ StrategySwingTrade inicializada (v2.0 - RSI + Stop Promovido)")
        self.logger.info(f"   RSI Entrada: {self.rsi_limite_compra} | Timeframe: {self.rsi_timeframe_entrada}")
        self.logger.info(f"   SL Inicial: {self.stop_loss_inicial_pct}% | TSL Dist√¢ncia: {self.trailing_stop_distancia_pct}%")

    def verificar_oportunidade(self, preco_atual: Decimal, tempo_atual: Optional[float] = None) -> Optional[Dict[str, Any]]:
        """
        Verifica se existe oportunidade de trade (compra ou venda)

        Args:
            preco_atual: Pre√ßo atual do ativo
            tempo_atual: Timestamp atual em segundos (opcional - para backtesting). Se None, usa time.time()

        Returns:
            Dict com dados da oportunidade ou None
        """
        if not self.habilitado:
            self.logger.debug("[SwingTrade] Estrat√©gia DESABILITADA nas configura√ß√µes")
            return None

        # Verificar se j√° tem posi√ß√£o
        tem_posicao = self.position_manager.tem_posicao('giro_rapido')
        quantidade = self.position_manager.get_quantidade_total('giro_rapido')

        # Log de estado a cada 60 segundos (n√£o a cada verifica√ß√£o para evitar spam)
        import time
        agora_timestamp = tempo_atual if tempo_atual is not None else time.time()
        if self.ultima_log_status is None or (agora_timestamp - self.ultima_log_status) >= 60:
            rsi_atual = self._obter_rsi_atual()
            rsi_str = f"{rsi_atual:.2f}" if rsi_atual is not None else "N/A"
            self.logger.info(
                f"üìä Giro R√°pido | Pre√ßo: ${preco_atual:.6f} | "
                f"RSI: {rsi_str} | "
                f"Posi√ß√£o: {quantidade:.4f} | "
                f"Status: {'COM posi√ß√£o' if tem_posicao else 'SEM posi√ß√£o'}"
            )
            self.ultima_log_status = agora_timestamp

        if not tem_posicao:
            # SEM POSI√á√ÉO: Verificar oportunidade de COMPRA
            return self._verificar_oportunidade_compra(preco_atual, agora_timestamp)
        else:
            # COM POSI√á√ÉO: Verificar oportunidade de VENDA (SL ou TSL)
            return self._verificar_oportunidade_venda(preco_atual)

    def _obter_rsi_atual(self) -> Optional[Decimal]:
        """
        Obt√©m o RSI atual do ativo no timeframe configurado

        Returns:
            Valor do RSI (0-100) ou None se n√£o conseguir calcular
        """
        try:
            if self.exchange_api is None:
                return None

            par = self.config.get('par', 'ADA/USDT')
            klines = self.exchange_api.obter_klines(
                simbolo=par,
                intervalo=self.rsi_timeframe_entrada,
                limite=14  # RSI padr√£o usa 14 per√≠odos
            )

            if not klines or len(klines) < 14:
                self.logger.debug(f"‚ö†Ô∏è Insuficientes klines para RSI ({len(klines) if klines else 0} < 14)")
                return None

            # Extrair pre√ßos de fechamento
            closes = [Decimal(str(candle[4])) for candle in klines]

            # Calcular RSI manualmente (vers√£o simplificada)
            rsi = self._calcular_rsi_manual(closes)
            return rsi

        except Exception as e:
            self.logger.debug(f"‚ö†Ô∏è Erro ao obter RSI: {e}")
            return None

    def _calcular_rsi_manual(self, closes: list, period: int = 14) -> Decimal:
        """
        Calcula RSI manualmente a partir de uma lista de pre√ßos de fechamento

        Args:
            closes: Lista de pre√ßos de fechamento
            period: Per√≠odo do RSI (padr√£o: 14)

        Returns:
            Valor do RSI (0-100) como Decimal
        """
        if len(closes) < period + 1:
            return Decimal('50')  # RSI neutro se dados insuficientes

        closes = [Decimal(str(c)) for c in closes]

        # Calcular varia√ß√µes
        varia√ß√µes = [closes[i] - closes[i - 1] for i in range(1, len(closes))]

        # Separar ganhos e perdas
        ganhos = [v if v > 0 else Decimal('0') for v in varia√ß√µes[-period:]]
        perdas = [abs(v) if v < 0 else Decimal('0') for v in varia√ß√µes[-period:]]

        # M√©dia de ganhos e perdas
        media_ganhos = sum(ganhos) / Decimal(period)
        media_perdas = sum(perdas) / Decimal(period)

        # Calcular RS e RSI
        if media_perdas == 0:
            rsi = Decimal('100') if media_ganhos > 0 else Decimal('50')
        else:
            rs = media_ganhos / media_perdas
            rsi = Decimal('100') - (Decimal('100') / (Decimal('1') + rs))

        return rsi

    def _verificar_oportunidade_compra(self, preco_atual: Decimal, tempo_atual: Optional[float] = None) -> Optional[Dict[str, Any]]:
        """
        Verifica oportunidade de compra quando N√ÉO h√° posi√ß√£o

        L√≥gica:
        1. Verificar cooldown
        2. Verificar RSI < limite
        3. Calcular capital dispon√≠vel
        4. Registrar stop loss inicial

        Args:
            preco_atual: Pre√ßo atual do ativo
            tempo_atual: Timestamp atual em segundos

        Returns:
            Dict com dados da oportunidade de compra ou None
        """
        # VERIFICAR COOLDOWN: Evitar m√∫ltiplas compras em sequ√™ncia r√°pida
        if self.ultima_compra_timestamp is not None:
            import time
            agora = tempo_atual if tempo_atual is not None else time.time()
            tempo_desde_ultima_compra = agora - self.ultima_compra_timestamp
            if tempo_desde_ultima_compra < self.cooldown_segundos:
                self.logger.debug(f"‚è±Ô∏è Cooldown ativo: {int(self.cooldown_segundos - tempo_desde_ultima_compra)}s restantes")
                return None

        # VERIFICAR ENTRADA: RSI < Limite
        if not self.usar_filtro_rsi_entrada:
            self.logger.debug("[SwingTrade] Filtro RSI DESABILITADO - ignorando l√≥gica de compra")
            return None

        rsi_atual = self._obter_rsi_atual()

        if rsi_atual is None:
            self.logger.debug("[SwingTrade] N√£o conseguiu obter RSI - ignorando compra")
            return None

        self.logger.debug(
            f"[SwingTrade] Verificando entrada: RSI={rsi_atual:.2f}, Limite={self.rsi_limite_compra:.2f}"
        )

        # Log sobre o RSI (usando INFO para garantir visibilidade)
        self.logger.info(
            f"üìä Giro R√°pido | RSI: {rsi_atual:.2f} | "
            f"Limite: {self.rsi_limite_compra:.2f} | "
            f"Gatilho: {'SIM ‚úì' if rsi_atual < self.rsi_limite_compra else 'N√ÉO ‚úó'}"
        )

        # Verificar se RSI atingiu o gatilho
        if rsi_atual < self.rsi_limite_compra:
            self.logger.debug(f"[SwingTrade] ‚úÖ Gatilho RSI ATINGIDO!")

            # Calcular quanto comprar (100% do capital dispon√≠vel da carteira giro_rapido)
            capital_disponivel = self.gestao_capital.calcular_capital_disponivel('giro_rapido')

            self.logger.debug(f"üí∞ Giro R√°pido | Capital dispon√≠vel: ${capital_disponivel:.2f}")

            if capital_disponivel <= 0:
                self.logger.debug(
                    f"[SwingTrade] Compra BLOQUEADA. Capital dispon√≠vel: ${capital_disponivel:.2f} "
                    f"(aloca√ß√£o: {self.alocacao_capital_pct}%)"
                )
                self.logger.debug("‚ö†Ô∏è Oportunidade de compra detectada, mas SEM CAPITAL dispon√≠vel!")
                self.logger.debug(f"   Verifique saldo USDT e configura√ß√£o de aloca√ß√£o ({self.alocacao_capital_pct}%)")
                return None

            # Verificar valor m√≠nimo de ordem
            valor_minimo = Decimal(str(self.config.get('VALOR_MINIMO_ORDEM', 5.0)))
            if capital_disponivel < valor_minimo:
                self.logger.debug(
                    f"[SwingTrade] Compra BLOQUEADA. Capital ${capital_disponivel:.2f} < m√≠nimo ${valor_minimo:.2f}"
                )
                self.logger.debug(f"‚ö†Ô∏è Capital dispon√≠vel (${capital_disponivel:.2f}) abaixo do m√≠nimo (${valor_minimo:.2f})")
                return None

            # Validar com gest√£o de capital
            pode_comprar, motivo = self.gestao_capital.pode_comprar(capital_disponivel, 'giro_rapido')

            if not pode_comprar:
                self.logger.debug(f"[SwingTrade] Compra BLOQUEADA pela gest√£o de capital: {motivo}")
                self.logger.debug(f"‚ö†Ô∏è Compra bloqueada pela gest√£o de capital: {motivo}")
                if self.notifier:
                    titulo = "Compra Bloqueada (Giro R√°pido)"
                    mensagem = (
                        f"Oportunidade de compra para Giro R√°pido foi encontrada, mas n√£o executada.\n\n"
                        f"üîí **Bloqueio:** Gest√£o de Capital\n"
                        f"üìÑ **Motivo:** {motivo}"
                    )
                    self.notifier.enviar_alerta(titulo, mensagem)
                return None

            quantidade = capital_disponivel / preco_atual

            # Calcular n√≠vel de stop loss inicial
            stop_loss_nivel = preco_atual * (Decimal('1') - self.stop_loss_inicial_pct / Decimal('100'))

            self.logger.info(f"üéØ OPORTUNIDADE DE COMPRA (Giro R√°pido)")
            self.logger.info(f"   RSI: {rsi_atual:.2f}% (limite: {self.rsi_limite_compra:.2f}%)")
            self.logger.info(f"   Pre√ßo atual: ${preco_atual:.6f}")
            self.logger.info(f"   Valor: ${capital_disponivel:.2f} ({quantidade:.4f} moedas)")
            self.logger.info(f"   üõ°Ô∏è Stop Loss (Inicial): ${stop_loss_nivel:.6f} ({self.stop_loss_inicial_pct}%)")

            return {
                'tipo': 'compra',
                'carteira': 'giro_rapido',
                'quantidade': quantidade,
                'preco_atual': preco_atual,
                'valor_operacao': capital_disponivel,
                'motivo': f'RSI {rsi_atual:.2f}% < {self.rsi_limite_compra:.2f}% - Giro R√°pido',
                'rsi_entrada': rsi_atual,
                'stop_loss_nivel': stop_loss_nivel  # N√≠vel de stop loss inicial
            }
        else:
            # DEBUG: Log quando compra √© bloqueada
            self.logger.debug(
                f"[SwingTrade] Compra bloqueada. RSI {rsi_atual:.2f}% >= limite {self.rsi_limite_compra:.2f}%"
            )

        return None

    def _verificar_oportunidade_venda(self, preco_atual: Decimal) -> Optional[Dict[str, Any]]:
        """
        Verifica oportunidade de venda quando H√Å posi√ß√£o

        L√≥gica:
        1. Calcular lucro atual
        2. Verificar se Stop Loss foi disparado
        3. Verificar se TSL foi disparado
        4. Retornar sinal de venda se algum stop disparou

        Args:
            preco_atual: Pre√ßo atual do ativo

        Returns:
            Dict com dados da oportunidade de venda ou None
        """
        # Calcular lucro atual
        lucro_atual = self.position_manager.calcular_lucro_atual(preco_atual, 'giro_rapido')

        if lucro_atual is None:
            self.logger.warning("‚ö†Ô∏è N√£o foi poss√≠vel calcular lucro atual (giro r√°pido)")
            return None

        preco_medio = self.position_manager.get_preco_medio('giro_rapido')

        # DEBUG: Log detalhado da l√≥gica de venda
        self.logger.debug(
            f"[SwingTrade] Posi√ß√£o ATIVA. Lucro: {lucro_atual:.2f}%. "
            f"Pre√ßo M√©dio: ${preco_medio:.6f}. Pre√ßo Atual: ${preco_atual:.6f}."
        )

        # Calcular n√≠veis de stops
        stop_loss_nivel = preco_medio * (Decimal('1') - self.stop_loss_inicial_pct / Decimal('100'))

        self.logger.debug(
            f"üìà Giro R√°pido - Lucro: {lucro_atual:.2f}% | "
            f"SL Inicial: ${stop_loss_nivel:.6f}"
        )

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # VERIFICA√á√ÉO 1: STOP LOSS INICIAL
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if preco_atual <= stop_loss_nivel:
            self.logger.debug(f"[SwingTrade] ‚úÖ STOP LOSS INICIAL DISPARADO!")
            self.logger.info(f"üõë STOP LOSS INICIAL DISPARADO (Giro R√°pido)")
            self.logger.info(f"   Lucro: {lucro_atual:.2f}%")
            self.logger.info(f"   Pre√ßo: ${preco_atual:.6f} <= SL: ${stop_loss_nivel:.6f}")

            return {
                'tipo': 'venda',
                'carteira': 'giro_rapido',
                'preco_atual': preco_atual,
                'lucro_percentual': lucro_atual,
                'motivo': f'Stop Loss Inicial - Lucro: {lucro_atual:.2f}%',
                'motivo_venda': 'stop_loss'
            }

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # VERIFICA√á√ÉO 2: PROMO√á√ÉO DE STOP (SL ‚Üí TSL no breakeven)
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # Retornar sinal para promover o stop de SL para TSL
        if lucro_atual >= 0:
            self.logger.debug(f"[SwingTrade] ‚úÖ BREAKEVEN ATINGIDO - Promover SL para TSL!")
            self.logger.info(f"üéØ PROMO√á√ÉO DE STOP (Giro R√°pido)")
            self.logger.info(f"   Lucro atingiu: {lucro_atual:.2f}% (breakeven)")
            self.logger.info(f"   Promovendo Stop Loss Inicial ‚Üí Trailing Stop Loss")
            self.logger.info(f"   TSL Dist√¢ncia: {self.trailing_stop_distancia_pct}%")

            return {
                'acao': 'promover_stop',
                'carteira': 'giro_rapido',
                'preco_atual': preco_atual,
                'lucro_atual': lucro_atual,
                'distancia_tsl_pct': self.trailing_stop_distancia_pct,
                'motivo': f'Breakeven atingido ({lucro_atual:.2f}%) - Promover para TSL'
            }

        return None

    def registrar_compra_executada(self, oportunidade: Dict[str, Any], tempo_atual: Optional[float] = None):
        """
        Registra que uma compra foi executada

        Args:
            oportunidade: Dados da oportunidade que foi executada
            tempo_atual: Timestamp atual em segundos (opcional - para backtesting). Se None, usa time.time()
        """
        import time

        # Registrar timestamp da compra para ativar cooldown
        self.ultima_compra_timestamp = tempo_atual if tempo_atual is not None else time.time()

        self.logger.info(f"üìà Compra executada (Giro R√°pido)")
        self.logger.info(f"‚è±Ô∏è Cooldown ativado: pr√≥xima compra permitida em {self.cooldown_segundos}s")

    def registrar_venda_executada(self, oportunidade: Dict[str, Any]):
        """
        Registra que uma venda foi executada

        Args:
            oportunidade: Dados da oportunidade que foi executada
        """
        # Resetar cooldown ap√≥s venda (permitir nova compra imediatamente)
        self.ultima_compra_timestamp = None

        lucro = oportunidade.get('lucro_percentual', 0)
        self.logger.info(f"üí∞ Venda executada (Giro R√°pido) - Ciclo completo. Lucro: {lucro:.2f}%")
        self.logger.info(f"‚úÖ Cooldown resetado - pr√≥xima compra pode ocorrer imediatamente")

    def obter_estatisticas(self) -> Dict[str, Any]:
        """
        Retorna estat√≠sticas da estrat√©gia

        Returns:
            Dict com estat√≠sticas
        """
        quantidade = self.position_manager.get_quantidade_total('giro_rapido')
        preco_medio = self.position_manager.get_preco_medio('giro_rapido')

        return {
            'estrategia': 'Giro R√°pido (RSI + Stop Promovido)',
            'habilitada': self.habilitado,
            'quantidade_posicao': quantidade,
            'preco_medio': preco_medio,
            'alocacao_capital_pct': self.alocacao_capital_pct,
            'rsi_limite_compra': self.rsi_limite_compra,
            'rsi_timeframe': self.rsi_timeframe_entrada,
            'stop_loss_inicial_pct': self.stop_loss_inicial_pct,
            'trailing_stop_distancia_pct': self.trailing_stop_distancia_pct
        }


if __name__ == '__main__':
    """Teste b√°sico"""
    from src.persistencia.database import DatabaseManager

    # Configura√ß√£o de teste
    config_teste = {
        'DATABASE_PATH': 'dados/bot_trading.db',
        'BACKUP_DIR': 'dados/backup',
        'VALOR_MINIMO_ORDEM': 5.0,
        'par': 'ADA/USDT',
        'ESTRATEGIAS': {
            'giro_rapido': True
        },
        'estrategia_giro_rapido': {
            'habilitado': True,
            'alocacao_capital_pct': 20,
            'usar_filtro_rsi_entrada': True,
            'rsi_timeframe_entrada': '15m',
            'rsi_limite_compra': 30,
            'stop_loss_inicial_pct': 2.5,
            'trailing_stop_distancia_pct': 0.8
        }
    }

    db = DatabaseManager(Path('dados/bot_trading.db'), Path('dados/backup'))
    position_mgr = PositionManager(db)
    gestao_cap = GestaoCapital(saldo_usdt=Decimal('100'), percentual_reserva=Decimal('8'))
    analise = AnaliseTecnica(None)

    strategy = StrategySwingTrade(config_teste, position_mgr, gestao_cap, analise)

    print("\n" + "="*60)
    print("TESTE: Strategy Swing Trade v2.0")
    print("="*60)

    stats = strategy.obter_estatisticas()
    print(f"\nEstrat√©gia: {stats['estrategia']}")
    print(f"Habilitada: {stats['habilitada']}")
    print(f"Aloca√ß√£o: {stats['alocacao_capital_pct']}%")
    print(f"RSI Limite: {stats['rsi_limite_compra']}%")
    print(f"SL Inicial: {stats['stop_loss_inicial_pct']}%")
    print(f"TSL Dist√¢ncia: {stats['trailing_stop_distancia_pct']}%")
    print(f"\n‚úÖ Estrat√©gia de Giro R√°pido v2.0 inicializada com sucesso!")
