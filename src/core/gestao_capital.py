"""
Gest√£o de Capital - Valida√ß√£o rigorosa de saldo e reserva

PROTE√á√ÉO CR√çTICA:
- Nunca permitir opera√ß√µes que violem a reserva de 8%
- Sempre manter m√≠nimo de $5 USDT em saldo
- Validar ANTES e DEPOIS de cada opera√ß√£o
"""

from decimal import Decimal
from typing import Optional, Tuple
from pathlib import Path
import sys

# Adicionar path do projeto
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from src.utils.logger import get_loggers

# Logger usa configura√ß√£o padr√£o (n√£o precisa especificar n√≠vel)
logger, _ = get_loggers(
    log_dir=Path('logs'),
    console=True
)


class GestaoCapital:
    """
    Gerenciador de capital com valida√ß√£o rigorosa de reserva

    Suporta m√∫ltiplas carteiras l√≥gicas:
    - 'acumulacao': Carteira principal de acumula√ß√£o (DCA)
    - 'giro_rapido': Carteira de swing trade (opera√ß√µes r√°pidas)

    REGRAS:
    - Reserva obrigat√≥ria: 8% do capital total
    - Saldo m√≠nimo: $5.00 USDT
    - Capital ativo: 92% dispon√≠vel para trading
    - Cada carteira tem seu pr√≥prio saldo alocado
    """

    def __init__(self, saldo_usdt: Decimal = Decimal('0'), valor_posicao_ada: Decimal = Decimal('0'), percentual_reserva: Decimal = Decimal('8'), modo_simulacao: bool = False, exchange_api=None):
        """
        Inicializar gestor de capital

        Args:
            saldo_usdt: Saldo total atual em USDT
            valor_posicao_ada: Valor da posi√ß√£o em ADA (em USDT) - carteira acumula√ß√£o
            percentual_reserva: Percentual da reserva (padr√£o: 8%)
            modo_simulacao: Se True, permite atualiza√ß√£o direta de saldo (para backtesting)
            exchange_api: Refer√™ncia √† API de exchange (necess√°ria para sincroniza√ß√£o em modo simula√ß√£o)
        """
        self.saldo_usdt = saldo_usdt
        self.percentual_reserva = percentual_reserva / Decimal('100')
        self.saldo_minimo = Decimal('5.00')
        self.modo_simulacao = modo_simulacao
        self.exchange_api = exchange_api  # Necess√°rio para modo simula√ß√£o

        # Carteiras separadas
        self.carteiras = {
            'acumulacao': {
                'valor_posicao': valor_posicao_ada,
                'saldo_alocado': Decimal('0')  # Calculado dinamicamente
            },
            'giro_rapido': {
                'valor_posicao': Decimal('0'),
                'saldo_alocado': Decimal('0')  # Percentual do saldo livre
            }
        }

        # ‚úÖ Aloca√ß√£o ser√° configurada via configurar_alocacao_giro_rapido()
        # N√ÉO usar padr√£o hardcoded aqui - deixar None para detectar se foi configurado
        self.alocacao_giro_rapido_pct = None
        # √öltimo motivo de bloqueio registrado (para evitar spam de logs)
        # Guardamos a √∫ltima mensagem de motivo retornada por pode_comprar e s√≥
        # logamos novamente se o motivo mudar (ou se a opera√ß√£o for aprovada).
        self._ultimo_motivo_bloqueio = None

    def configurar_alocacao_giro_rapido(self, percentual: Decimal):
        """
        Configura o percentual de aloca√ß√£o para a carteira de giro r√°pido

        Args:
            percentual: Percentual do saldo livre a alocar para giro r√°pido
        """
        self.alocacao_giro_rapido_pct = percentual
        logger.debug(f"‚öôÔ∏è Aloca√ß√£o giro r√°pido configurada: {percentual}%")

    def atualizar_saldo_usdt_simulado(self, novo_saldo: Decimal):
        """
        Atualiza o saldo USDT diretamente (usado em modo simula√ß√£o)

        IMPORTANTE: Este m√©todo s√≥ deve ser chamado em modo simula√ß√£o,
        quando o BotWorker precisa sincronizar o saldo ap√≥s opera√ß√µes
        na SimulatedExchangeAPI.

        Args:
            novo_saldo: Novo saldo USDT obtido da API simulada
        """
        if not self.modo_simulacao:
            logger.warning("‚ö†Ô∏è Tentativa de atualizar saldo simulado fora do modo simula√ß√£o - ignorando")
            return

        saldo_anterior = self.saldo_usdt
        self.saldo_usdt = novo_saldo
        
        diferenca = novo_saldo - saldo_anterior
        simbolo = "+" if diferenca >= 0 else ""
        logger.debug(f"üí∞ Saldo USDT atualizado: ${saldo_anterior:.2f} ‚Üí ${novo_saldo:.2f} ({simbolo}{diferenca:.2f})")

    def set_saldo_usdt_simulado(self, novo_saldo: Decimal, carteira: str):
        """
        Sincroniza o saldo USDT total com base nos saldos individuais das carteiras.

        IMPORTANTE: Este m√©todo √© espec√≠fico para modo simula√ß√£o. Ele N√ÉO sobrescreve
        o saldo total com o valor de uma carteira. Em vez disso, calcula o saldo total
        como a soma dos saldos de AMBAS as carteiras (giro_rapido + acumulacao).

        Isso previne desincroniza√ß√£o entre GestaoCapital e SimulatedExchangeAPI.

        Args:
            novo_saldo: Novo saldo USDT da carteira especificada (usado apenas para log)
            carteira: Nome da carteira ('acumulacao' ou 'giro_rapido')
        """
        if not self.modo_simulacao:
            logger.warning("‚ö†Ô∏è Tentativa de usar set_saldo_usdt_simulado fora do modo simula√ß√£o - ignorando")
            return

        # IMPORTANTE: Calcular saldo total como SOMA de ambas as carteiras
        # em vez de sobrescrever com o valor de uma √∫nica carteira
        try:
            saldo_giro = Decimal(str(self.exchange_api.saldos_por_carteira['giro_rapido']['saldo_usdt']))
            saldo_acum = Decimal(str(self.exchange_api.saldos_por_carteira['acumulacao']['saldo_usdt']))
            saldo_total_novo = saldo_giro + saldo_acum
        except (KeyError, AttributeError, TypeError) as e:
            # Fallback se algo der errado com o acesso √† API
            logger.warning(f"‚ö†Ô∏è Erro ao sincronizar saldo total: {e}. Usando valor fornecido como fallback.")
            saldo_total_novo = novo_saldo

        saldo_anterior = self.saldo_usdt
        self.saldo_usdt = saldo_total_novo

        diferenca = saldo_total_novo - saldo_anterior
        simbolo = "+" if diferenca >= 0 else ""
        logger.debug(f"üí∞ Saldo USDT sincronizado [{carteira}]: ${saldo_anterior:.2f} ‚Üí ${saldo_total_novo:.2f} ({simbolo}{diferenca:.2f})")

    def atualizar_saldos(self, saldo_usdt: Decimal, valor_posicao_ada: Decimal = Decimal('0'), carteira: str = 'acumulacao'):
        """
        Atualizar saldos para rec√°lculo

        Args:
            saldo_usdt: Novo saldo USDT total
            valor_posicao_ada: Novo valor da posi√ß√£o (em USDT)
            carteira: Nome da carteira ('acumulacao' ou 'giro_rapido')
        """
        self.saldo_usdt = saldo_usdt

        if carteira in self.carteiras:
            self.carteiras[carteira]['valor_posicao'] = valor_posicao_ada
        else:
            logger.warning(f"‚ö†Ô∏è Carteira '{carteira}' n√£o reconhecida. Use 'acumulacao' ou 'giro_rapido'")

    def get_valor_posicao_total(self) -> Decimal:
        """
        Retorna o valor total investido em todas as carteiras

        Returns:
            Valor total das posi√ß√µes em USDT
        """
        return sum(carteira['valor_posicao'] for carteira in self.carteiras.values())

    def calcular_capital_total(self) -> Decimal:
        """
        Calcula capital total (USDT + todas as posi√ß√µes)

        Returns:
            Capital total em USDT
        """
        return self.saldo_usdt + self.get_valor_posicao_total()

    def calcular_reserva_obrigatoria(self) -> Decimal:
        """
        Calcula reserva obrigat√≥ria (8% do capital total)

        Returns:
            Valor da reserva em USDT
        """
        capital_total = self.calcular_capital_total()
        return capital_total * self.percentual_reserva

    def calcular_capital_disponivel(self, carteira: str = 'acumulacao') -> Decimal:
        """
        Calcula capital dispon√≠vel para trading por carteira

        Em modo simula√ß√£o, usa o saldo REAL da carteira (n√£o recalcula percentual).
        Em modo real, calcula a divis√£o dinamicamente com base no saldo total.

        Args:
            carteira: Nome da carteira ('acumulacao' ou 'giro_rapido')

        Returns:
            Capital dispon√≠vel em USDT para a carteira especificada
        """
        if self.modo_simulacao:
            # ‚úÖ CR√çTICO: Em modo simula√ß√£o, usar o saldo REAL da API
            # N√£o recalcular percentuais! A SimulatedExchangeAPI j√° mant√©m
            # os saldos separados corretamente ap√≥s cada trade.
            try:
                saldo_carteira = Decimal(str(
                    self.exchange_api.saldos_por_carteira[carteira]['saldo_usdt']
                ))
                # Aplicar reserva apenas se necess√°rio
                reserva = self.calcular_reserva_obrigatoria()
                return max(saldo_carteira - reserva, Decimal('0'))
            except (KeyError, AttributeError, TypeError) as e:
                logger.warning(f"‚ö†Ô∏è Erro ao obter saldo da carteira '{carteira}': {e}")
                return Decimal('0')
        else:
            # Em modo real: calcular dividindo o saldo livre
            reserva = self.calcular_reserva_obrigatoria()
            saldo_livre = self.saldo_usdt - reserva

            if saldo_livre <= 0:
                return Decimal('0')

            if carteira == 'giro_rapido':
                # ‚úÖ Valida√ß√£o: alocacao_giro_rapido_pct DEVE ter sido configurado
                if self.alocacao_giro_rapido_pct is None:
                    logger.error("‚ùå ERRO CR√çTICO: alocacao_giro_rapido_pct n√£o foi configurada! "
                                 "BotWorker.configurar_alocacao_giro_rapido() deve ser chamado durante inicializa√ß√£o.")
                    raise ValueError("alocacao_giro_rapido_pct n√£o foi configurada - imposs√≠vel alocar capital")

                # Giro r√°pido usa um percentual do saldo livre
                return saldo_livre * (self.alocacao_giro_rapido_pct / Decimal('100'))
            elif carteira == 'acumulacao':
                # ‚úÖ Valida√ß√£o: alocacao_giro_rapido_pct DEVE ter sido configurado
                if self.alocacao_giro_rapido_pct is None:
                    logger.error("‚ùå ERRO CR√çTICO: alocacao_giro_rapido_pct n√£o foi configurada! "
                                 "BotWorker.configurar_alocacao_giro_rapido() deve ser chamado durante inicializa√ß√£o.")
                    raise ValueError("alocacao_giro_rapido_pct n√£o foi configurada - imposs√≠vel alocar capital")

                # Acumula√ß√£o usa o restante do saldo livre
                saldo_giro_rapido = saldo_livre * (self.alocacao_giro_rapido_pct / Decimal('100'))
                return saldo_livre - saldo_giro_rapido

        logger.warning(f"‚ö†Ô∏è Carteira '{carteira}' desconhecida. Retornando 0.")
        return Decimal('0')

    def get_alocacao_percentual_ada(self, carteira: str = 'acumulacao') -> Decimal:
        """
        Calcula o percentual do capital total que est√° alocado em ADA por carteira

        Args:
            carteira: Nome da carteira ('acumulacao' ou 'giro_rapido')

        Returns:
            Percentual de aloca√ß√£o
        """
        capital_total = self.calcular_capital_total()
        if capital_total <= 0:
            return Decimal('0')

        if carteira in self.carteiras:
            valor_posicao = self.carteiras[carteira]['valor_posicao']
            return (valor_posicao / capital_total) * Decimal('100')
        else:
            # Retornar total de todas as carteiras
            valor_total_posicoes = self.get_valor_posicao_total()
            return (valor_total_posicoes / capital_total) * Decimal('100')

    def pode_comprar(self, valor_operacao: Decimal, carteira: str = 'acumulacao') -> Tuple[bool, str]:
        """
        Valida se pode comprar sem violar reserva, respeitando aloca√ß√£o por carteira.

        VALIDA√á√ïES:
        1. Capital dispon√≠vel suficiente para a carteira especificada
        2. Saldo ap√≥s compra mant√©m reserva global
        3. Saldo ap√≥s compra >= $5.00

        Args:
            valor_operacao: Valor da opera√ß√£o em USDT
            carteira: Nome da carteira ('acumulacao' ou 'giro_rapido')

        Returns:
            (pode: bool, motivo: str)
        """
        # 1. Calcular reserva obrigat√≥ria
        capital_total = self.calcular_capital_total()
        reserva_obrigatoria = self.calcular_reserva_obrigatoria()

        logger.debug(f"üí∞ Capital total: ${capital_total:.2f}")
        logger.debug(f"üõ°Ô∏è Reserva obrigat√≥ria (8%): ${reserva_obrigatoria:.2f}")

        # 2. Capital dispon√≠vel para a carteira espec√≠fica
        capital_disponivel = self.calcular_capital_disponivel(carteira)

        logger.debug(f"‚úÖ Capital dispon√≠vel ({carteira}): ${capital_disponivel:.2f}")
        logger.debug(f"üéØ Valor opera√ß√£o: ${valor_operacao:.2f}")

        # 3. Verificar se tem saldo dispon√≠vel na carteira
        if capital_disponivel < valor_operacao:
            motivo = (
                f"Capital insuficiente na carteira '{carteira}': ${capital_disponivel:.2f} < ${valor_operacao:.2f} "
                f"(Reserva protegida: ${reserva_obrigatoria:.2f})"
            )
            # Evitar spam: logar apenas se o motivo mudou desde a √∫ltima vez
            if motivo != getattr(self, '_ultimo_motivo_bloqueio', None):
                logger.warning(f"‚ö†Ô∏è {motivo}")
                self._ultimo_motivo_bloqueio = motivo
            return False, motivo

        # 4. Simular saldo ap√≥s compra
        saldo_apos = self.saldo_usdt - valor_operacao

        logger.debug(f"üìä Saldo ap√≥s compra: ${saldo_apos:.2f}")

        # 5. Verificar se mant√©m reserva AP√ìS compra
        if saldo_apos < reserva_obrigatoria:
            motivo = (
                f"Opera√ß√£o violaria reserva de 8%: saldo ap√≥s (${saldo_apos:.2f}) < "
                f"reserva (${reserva_obrigatoria:.2f})"
            )
            # Evitar spam: logar apenas se o motivo mudou desde a √∫ltima vez
            if motivo != getattr(self, '_ultimo_motivo_bloqueio', None):
                logger.warning(f"üõ°Ô∏è {motivo}")
                self._ultimo_motivo_bloqueio = motivo
            return False, motivo

        # 6. Nunca deixar menos de $5
        if saldo_apos < self.saldo_minimo:
            motivo = f"Saldo ficaria abaixo do m√≠nimo: ${saldo_apos:.2f} < ${self.saldo_minimo:.2f}"
            # Evitar spam: logar apenas se o motivo mudou desde a √∫ltima vez
            if motivo != getattr(self, '_ultimo_motivo_bloqueio', None):
                logger.warning(f"‚ö†Ô∏è {motivo}")
                self._ultimo_motivo_bloqueio = motivo
            return False, motivo

        # ‚úÖ APROVADO
        # Limpar √∫ltimo motivo de bloqueio quando uma opera√ß√£o √© aprovada
        self._ultimo_motivo_bloqueio = None
        logger.debug(f"‚úÖ Opera√ß√£o aprovada ({carteira}): ${valor_operacao:.2f}")
        logger.debug(f"   Saldo ap√≥s: ${saldo_apos:.2f} (reserva: ${reserva_obrigatoria:.2f})")

        return True, ""

    def pode_vender(self, quantidade_ada: Decimal, preco_ada: Decimal) -> Tuple[bool, str]:
        """
        Valida se pode vender (sempre permitido, aumenta USDT)

        Args:
            quantidade_ada: Quantidade de ADA a vender
            preco_ada: Pre√ßo do ADA

        Returns:
            (pode: bool, motivo: str)
        """
        valor_venda = quantidade_ada * preco_ada

        # Venda sempre √© permitida (aumenta capital)
        logger.debug(f"‚úÖ Venda aprovada: {quantidade_ada} ADA @ ${preco_ada:.6f} = ${valor_venda:.2f}")

        return True, ""

    def obter_resumo(self) -> dict:
        """
        Obt√©m resumo do capital e reserva com detalhamento por carteira

        Returns:
            Dicion√°rio com informa√ß√µes do capital
        """
        capital_total = self.calcular_capital_total()
        reserva_obrigatoria = self.calcular_reserva_obrigatoria()
        capital_disponivel_acumulacao = self.calcular_capital_disponivel('acumulacao')
        capital_disponivel_giro = self.calcular_capital_disponivel('giro_rapido')

        return {
            'saldo_usdt': self.saldo_usdt,
            'capital_total': capital_total,
            'reserva_obrigatoria': reserva_obrigatoria,
            'percentual_reserva': float(self.percentual_reserva * 100),
            'saldo_minimo': self.saldo_minimo,
            'carteiras': {
                'acumulacao': {
                    'valor_posicao': self.carteiras['acumulacao']['valor_posicao'],
                    'capital_disponivel': capital_disponivel_acumulacao
                },
                'giro_rapido': {
                    'valor_posicao': self.carteiras['giro_rapido']['valor_posicao'],
                    'capital_disponivel': capital_disponivel_giro,
                    'alocacao_pct': float(self.alocacao_giro_rapido_pct)
                }
            }
        }

    def log_resumo(self):
        """Exibe resumo do capital no log com detalhamento por carteira"""
        resumo = self.obter_resumo()

        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        logger.info("üí∞ GEST√ÉO DE CAPITAL (M√∫ltiplas Carteiras)")
        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        logger.info(f"   Saldo USDT Total: ${resumo['saldo_usdt']:.2f}")
        logger.info(f"   Capital Total: ${resumo['capital_total']:.2f}")
        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        logger.info(f"   üõ°Ô∏è Reserva ({resumo['percentual_reserva']:.0f}%): ${resumo['reserva_obrigatoria']:.2f}")
        logger.info(f"   ‚ö†Ô∏è M√≠nimo obrigat√≥rio: ${resumo['saldo_minimo']:.2f}")
        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        logger.info("   üìä CARTEIRA ACUMULA√á√ÉO:")
        logger.info(f"      Posi√ß√£o: ${resumo['carteiras']['acumulacao']['valor_posicao']:.2f}")
        logger.info(f"      Dispon√≠vel: ${resumo['carteiras']['acumulacao']['capital_disponivel']:.2f}")
        logger.info("   üìà CARTEIRA GIRO R√ÅPIDO:")
        logger.info(f"      Posi√ß√£o: ${resumo['carteiras']['giro_rapido']['valor_posicao']:.2f}")
        logger.info(f"      Dispon√≠vel: ${resumo['carteiras']['giro_rapido']['capital_disponivel']:.2f}")
        logger.info(f"      Aloca√ß√£o: {resumo['carteiras']['giro_rapido']['alocacao_pct']:.0f}%")
        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")


# Fun√ß√£o auxiliar para uso direto
def validar_compra(saldo_usdt: Decimal, valor_operacao: Decimal,
                   valor_posicao_ada: Decimal = Decimal('0')) -> Tuple[bool, str]:
    """
    Fun√ß√£o auxiliar para validar compra rapidamente

    Args:
        saldo_usdt: Saldo atual USDT
        valor_operacao: Valor da opera√ß√£o
        valor_posicao_ada: Valor da posi√ß√£o ADA

    Returns:
        (pode: bool, motivo: str)
    """
    gestor = GestaoCapital(saldo_usdt, valor_posicao_ada)
    return gestor.pode_comprar(valor_operacao)
